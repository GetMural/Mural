{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./node_modules/scrollstory/jquery.scrollstory.js","webpack:///./src/client/items/VideoBackground.js","webpack:///external \"jQuery\""],"names":[],"mappings":";QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;AClFA;AACA;AACA;AACA,mCAAmC;AACnC;;AAEA;AACA,MAAM,IAA0C;AAChD,IAAI,iCAAO,CAAC,2CAAQ,CAAC,oCAAE,OAAO;AAAA;AAAA;AAAA,oGAAC;AAC/B,GAAG,MAAM,EAEN;AACH,CAAC;;AAED;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA,mCAAmC;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,cAAc;AAC5B,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA,8BAA8B;;AAE9B;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,QAAQ;AACtC;AACA,oBAAoB;AACpB;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA,SAAS;AACT;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;;AAGL;AACA;AACA;AACA,gBAAgB,OAAO;AACvB,gBAAgB,SAAS;AACzB,gBAAgB,OAAO;AACvB;AACA;AACA;AACA,yDAAyD;AACzD,OAAO;AACP;AACA;AACA,KAAK;;;AAGL;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,KAAK;;;AAGL;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,yC;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,KAAK;;;AAGL;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,KAAK;;;AAGL;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;;AAGL;AACA;AACA;AACA,gCAAgC,uBAAuB;AACvD;AACA,eAAe;AACf;AACA;AACA;AACA,KAAK;;;AAGL;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,KAAK;;;AAGL;AACA;AACA;AACA,gBAAgB,OAAO;AACvB,gBAAgB;AAChB;AACA;AACA;AACA,KAAK;;;AAGL;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB,gBAAgB;AAChB;AACA;AACA;AACA,KAAK;;;AAGL;AACA;AACA;AACA,+CAA+C,uCAAuC;AACtF;AACA,eAAe,SAAS;AACxB,gBAAgB,MAAM;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP,KAAK;;;AAGL;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,QAAQ;AACnC,2BAA2B,eAAe;AAC1C,2BAA2B,4BAA4B;AACvD;AACA;AACA,2BAA2B,uBAAuB,oBAAoB;AACtE;AACA;AACA,2BAA2B,uBAAuB,kBAAkB,EAAE,EAAE;AACxE;AACA;AACA,2BAA2B,uCAAuC,oBAAoB,EAAE;AACxF;AACA,gBAAgB,OAAO;AACvB,gBAAgB,MAAM;AACtB;AACA;AACA;AACA,mBAAmB;;AAEnB;AACA,uCAAuC;AACvC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,aAAa;;AAEb;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA,KAAK;;;AAGL;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;;;AAGL;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,KAAK;;;AAGL;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,KAAK;;;AAGL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA,KAAK;;;AAGL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;;;AAGL;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;;;AAGL;AACA;AACA;AACA,gBAAgB,OAAO;AACvB,gBAAgB;AAChB;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;;;AAGL;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,KAAK;;;AAGL;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;;AAGL;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA,KAAK;;;AAGL;AACA;AACA;AACA;AACA,6CAA6C,0CAA0C;AACvF;AACA,eAAe,SAAS;AACxB,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;;AAGL;AACA;AACA;AACA;AACA;AACA,kCAAkC,QAAQ;AAC1C;AACA,eAAe,SAAS;AACxB,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;;AAGL;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,KAAK;;;AAGL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;;AAGL;AACA;AACA;AACA;AACA;AACA,KAAK;;;AAGL;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA,KAAK;;;AAGL;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA,KAAK;;;AAGL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;;AAEP;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;;AAGL;AACA;AACA;AACA,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB,gBAAgB,SAAS;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;;AAGP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;;;AAGL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,SAAS;AACzB,gBAAgB,aAAa;AAC7B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;AACA,KAAK;;;AAGL;AACA;AACA;AACA,gBAAgB,aAAa;AAC7B;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;;AAGL;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;;AAGL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,YAAY;AAC7B;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,iBAAiB,YAAY;AAC7B;AACA;AACA,uFAAuF;AACvF;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,8FAA8F;AAC9F;;AAEA;;AAEA;AACA,KAAK;;;AAGL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,2BAA2B;AAC1C;AACA;;AAEA;AACA;AACA,OAAO;;AAEP;AACA;AACA;;AAEA;AACA,OAAO;AACP;;AAEA;AACA,OAAO;AACP;;AAEA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;;AAGL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB,gBAAgB,OAAO;AACvB;AACA;AACA;;AAEA;AACA,6BAA6B;AAC7B;;AAEA,oCAAoC;AACpC,4BAA4B;AAC5B,KAAK;;;AAGL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,OAAO;;AAEP;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,OAAO;AACP,KAAK;;;;AAIL;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA,KAAK;;;AAGL;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA,wBAAwB;AACxB,OAAO;AACP,KAAK;;;AAGL;AACA;AACA;AACA,gBAAgB,MAAM;AACtB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA,KAAK;;;AAGL;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,cAAc;AAC7B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,yBAAyB;;AAEzB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;;AAGL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;;;AAGJ;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,G;;;;;;;;;;;;ACxiDD;AAAA;AAAA;AAAA;AACA;AACwC;;AAExC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;AC7BA,aAAa,mCAAmC,EAAE,I","file":"VideoBackground.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n","/**\n* @preserve ScrollStory - vVERSIONXXX - YYYY-MM-DDXXX\n* https://github.com/sjwilliams/scrollstory\n* Copyright (c) 2017 Josh Williams; Licensed MIT \n*/\n\n(function(factory) {\n  if (typeof define === 'function' && define.amd) {\n    define(['jquery'], factory);\n  } else {\n    factory(jQuery);\n  }\n}(function($, undefined) {\n\n  var pluginName = 'scrollStory';\n  var eventNameSpace = '.' + pluginName;\n  var defaults = {\n\n    // jquery object, class selector string, or array of values, or null (to use existing DOM)\n    content: null,\n\n    // Only used if content null. Should be a class selector\n    contentSelector: '.story',\n\n    // Left/right keys to navigate\n    keyboard: true,\n\n    // Offset from top used in the programatic scrolling of an\n    // item to the focus position. Useful in the case of thinks like\n    // top nav that might obscure part of an item if it goes to 0.\n    scrollOffset: 0,\n\n    // Offset from top to trigger a change\n    triggerOffset: 0,\n\n    // Event to monitor. Can be a name for an event on the $(window), or\n    // a function that defines custom behavior. Defaults to native scroll event.\n    scrollEvent: 'scroll',\n\n    // Automatically activate the first item on load, \n    // regardless of its position relative to the offset\n    autoActivateFirstItem: false,\n\n    // Disable last item -- and the entire widget -- once it's scroll beyond the trigger point\n    disablePastLastItem: true,\n\n    // Automated scroll speed in ms. Set to 0 to remove animation.\n    speed: 800,\n\n    // Scroll easing. 'swing' or 'linear', unless an external plugin provides others\n    // http://api.jquery.com/animate/\n    easing: 'swing',\n\n    // // scroll-based events are either 'debounce' or 'throttle'\n    throttleType: 'throttle',\n\n    // frequency in milliseconds to perform scroll-based functions. Scrolling functions \n    // can be CPU intense, so higher number can help performance.\n    scrollSensitivity: 100,\n\n    // options to pass to underscore's throttle or debounce for scroll\n    // see: http://underscorejs.org/#throttle && http://underscorejs.org/#debounce\n    throttleTypeOptions: null,\n\n    // Update offsets after likely repaints, like window resizes and filters\n    autoUpdateOffsets: true,\n\n    debug: false,\n\n    // whether or not the scroll checking is enabled.\n    enabled: true,\n\n    setup: $.noop,\n    destroy: $.noop,\n    itembuild: $.noop,\n    itemfocus: $.noop,\n    itemblur: $.noop,\n    itemfilter: $.noop,\n    itemunfilter: $.noop,\n    itementerviewport: $.noop,\n    itemexitviewport: $.noop,\n    categoryfocus: $.noop,\n    categeryblur: $.noop,\n    containeractive: $.noop,\n    containerinactive: $.noop,\n    containerresize: $.noop,\n    containerscroll: $.noop,\n    updateoffsets: $.noop,\n    triggeroffsetupdate: $.noop,\n    scrolloffsetupdate: $.noop,\n    complete: $.noop\n  };\n\n  // static across all plugin instances\n  // so we can uniquely ID elements\n  var instanceCounter = 0;\n\n\n\n\n  /**\n   * Utility methods\n   *\n   * debounce() and throttle() are from on Underscore.js:\n   * https://github.com/jashkenas/underscore\n   */\n\n  /**\n   * Underscore's now:\n   * http://underscorejs.org/now\n   */\n  var dateNow = Date.now || function() {\n    return new Date().getTime();\n  };\n\n  /**\n   * Underscore's debounce:\n   * http://underscorejs.org/#debounce\n   */\n  var debounce = function(func, wait, immediate) {\n    var result;\n    var timeout = null;\n    return function() {\n      var context = this,\n        args = arguments;\n      var later = function() {\n        timeout = null;\n        if (!immediate) {\n          result = func.apply(context, args);\n        }\n      };\n      var callNow = immediate && !timeout;\n      clearTimeout(timeout);\n      timeout = setTimeout(later, wait);\n      if (callNow) {\n        result = func.apply(context, args);\n      }\n      return result;\n    };\n  };\n\n  /**\n   * Underscore's throttle:\n   * http://underscorejs.org/#throttle\n   */\n  var throttle = function(func, wait, options) {\n    var context, args, result;\n    var timeout = null;\n    var previous = 0;\n    options || (options = {});\n    var later = function() {\n      previous = options.leading === false ? 0 : dateNow();\n      timeout = null;\n      result = func.apply(context, args);\n    };\n    return function() {\n      var now = dateNow();\n      if (!previous && options.leading === false) {\n        previous = now;\n      }\n      var remaining = wait - (now - previous);\n      context = this;\n      args = arguments;\n      if (remaining <= 0) {\n        clearTimeout(timeout);\n        timeout = null;\n        previous = now;\n        result = func.apply(context, args);\n      } else if (!timeout && options.trailing !== false) {\n        timeout = setTimeout(later, remaining);\n      }\n      return result;\n    };\n  };\n\n  var $window = $(window);\n  var winHeight = $window.height(); // cached. updated via _handleResize()\n\n  /**\n   * Given a scroll/trigger offset, determine\n   * its pixel value from the top of the viewport. \n   * \n   * If number or number-like string (30 or '30'), return that \n   * number. (30)\n   *\n   * If it's a percentage string ('30%'), convert to pixels\n   * based on the height of the viewport. (eg: 395) \n   * \n   * @param  {String/Number} offset\n   * @return {Number}\n   */\n  var offsetToPx = function(offset){\n    var pxOffset;\n\n    if (offsetIsAPercentage(offset)) {\n      pxOffset = offset.slice(0, -1);\n      pxOffset = Math.round(winHeight * (parseInt(pxOffset, 10)/100) );\n    } else {\n      pxOffset = parseInt(offset, 10);\n    }\n\n    return pxOffset;\n  };\n\n  var offsetIsAPercentage = function(offset){\n    return typeof offset === 'string' && offset.slice(-1) === '%';\n  };\n\n\n  function ScrollStory(element, options) {\n    this.el = element;\n    this.$el = $(element);\n    this.options = $.extend({}, defaults, options);\n\n    this.useNativeScroll = (typeof this.options.scrollEvent === 'string') && (this.options.scrollEvent.indexOf('scroll') === 0);\n\n    this._defaults = defaults;\n    this._name = pluginName;\n    this._instanceId = (function() {\n      return pluginName + '_' + instanceCounter;\n    })();\n    \n    this.init();\n  }\n\n  ScrollStory.prototype = {\n    init: function() {\n      \n      /**\n       * List of all items, and a quick lockup hash\n       * Data populated via _prepItems* methods\n       */\n      this._items = [];\n      this._itemsById = {};\n      this._categories = [];\n      this._tags = [];\n\n      this._isActive = false;\n      this._activeItem;\n      this._previousItems = [];\n\n      /**\n       * Attach handlers before any events are dispatched\n       */\n      this.$el.on('setup'+eventNameSpace, this._onSetup.bind(this));\n      this.$el.on('destroy'+eventNameSpace, this._onDestroy.bind(this));\n      this.$el.on('containeractive'+eventNameSpace, this._onContainerActive.bind(this));\n      this.$el.on('containerinactive'+eventNameSpace, this._onContainerInactive.bind(this));\n      this.$el.on('itemblur'+eventNameSpace, this._onItemBlur.bind(this));\n      this.$el.on('itemfocus'+eventNameSpace, this._onItemFocus.bind(this));\n      this.$el.on('itementerviewport'+eventNameSpace, this._onItemEnterViewport.bind(this));\n      this.$el.on('itemexitviewport'+eventNameSpace, this._onItemExitViewport.bind(this));\n      this.$el.on('itemfilter'+eventNameSpace, this._onItemFilter.bind(this));\n      this.$el.on('itemunfilter'+eventNameSpace, this._onItemUnfilter.bind(this));\n      this.$el.on('categoryfocus'+eventNameSpace, this._onCategoryFocus.bind(this));\n      this.$el.on('triggeroffsetupdate'+eventNameSpace, this._onTriggerOffsetUpdate.bind(this));\n\n\n      /**\n       * Run before any items have been added, allows\n       * for user manipulation of page before ScrollStory\n       * acts on anything.\n       */\n      this._trigger('setup', null, this);\n\n\n      /**\n       * Convert data from outside of widget into\n       * items and, if needed, categories of items.\n       *\n       * Don't 'handleRepaints' just yet, as that'll\n       * set an active item. We want to do that after\n       * our 'complete' event is triggered.\n       */\n      this.addItems(this.options.content, {\n        handleRepaint: false\n      });\n\n      // 1. offsets need to be accurate before 'complete'\n      this.updateOffsets();\n\n      // 2. handle any user actions\n      this._trigger('complete', null, this);\n\n      // 3. Set active item, and double check \n      // scroll position and offsets.\n      if(this.options.enabled){\n        this._handleRepaint();\n      }\n\n\n      /**\n       * Bind keyboard events\n       */\n      if (this.options.keyboard) {\n        $(document).keydown(function(e){\n          var captured = true;\n          switch (e.keyCode) {\n            case 37:\n              if (e.metaKey) {return;} // ignore ctrl/cmd left, as browsers use that to go back in history\n              this.previous();\n              break; // left arrow\n            case 39:\n              this.next();\n              break; // right arrow\n            default:\n              captured = false;\n          }\n          return !captured;\n        }.bind(this));\n      }\n\n\n\n      /**\n       * Debug UI\n       */\n      this.$trigger = $('<div class=\"' + pluginName + 'Trigger\"></div>').css({\n        position: 'fixed',\n        width: '100%',\n        height: '1px',\n        top: offsetToPx(this.options.triggerOffset) + 'px',\n        left: '0px',\n        backgroundColor: '#ff0000',\n        '-webkit-transform': 'translateZ(0)',\n        '-webkit-backface-visibility': 'hidden',\n        zIndex: 1000\n      }).attr('id', pluginName + 'Trigger-' + this._instanceId);\n      \n      if (this.options.debug) {\n        this.$trigger.appendTo('body');\n      }\n\n\n      /**\n       * Watch either native scroll events, throttled by \n       * this.options.scrollSensitivity, or a custom event \n       * that implements its own throttling.\n       *\n       * Bind these events after 'complete' trigger so no\n       * items are active when those callbacks runs.\n       */\n      \n      var scrollThrottle, scrollHandler;\n\n      if(this.useNativeScroll){\n\n        // bind and throttle native scroll\n        scrollThrottle = (this.options.throttleType === 'throttle') ? throttle : debounce;\n        scrollHandler = scrollThrottle(this._handleScroll.bind(this), this.options.scrollSensitivity, this.options.throttleTypeOptions);\n        $window.on('scroll'+eventNameSpace, scrollHandler);\n      } else {\n\n        // bind but don't throttle custom event\n        scrollHandler = this._handleScroll.bind(this);\n\n        // if custom event is a function, it'll need\n        // to call the scroll handler manually, like so:\n        //\n        //  $container.scrollStory({\n        //    scrollEvent: function(cb){\n        //      // custom scroll event on nytimes.com\n        //      PageManager.on('nyt:page-scroll', function(){\n        //       // do something interesting if you like\n        //       // and then call the passed in handler();\n        //       cb();\n        //     });\n        //    }\n        //  });\n        //\n        //\n        // Otherwise, it's a string representing an event on the\n        // window to subscribe to, like so:\n        //\n        // // some code dispatching throttled events\n        // $window.trigger('nytg-scroll');\n        // \n        //  $container.scrollStory({\n        //    scrollEvent: 'nytg-scroll'\n        //  });\n        //\n\n        if (typeof this.options.scrollEvent === 'function') {\n          this.options.scrollEvent(scrollHandler);\n        } else {\n          $window.on(this.options.scrollEvent+eventNameSpace, function(){\n            scrollHandler();\n          });\n        }\n      }\n\n      // anything that might cause a repaint      \n      var resizeThrottle = debounce(this._handleResize, 100);\n      $window.on('DOMContentLoaded'+eventNameSpace + ' load'+eventNameSpace + ' resize'+eventNameSpace, resizeThrottle.bind(this));\n\n      instanceCounter = instanceCounter + 1;\n    },\n\n\n    /**\n     * Get current item's index, \n     * or set the current item with an index.\n     * @param  {Number} index\n     * @param  {Function} callback\n     * @return {Number} index of active item\n     */\n    index: function(index, callback) {\n      if (typeof index === 'number' && this.getItemByIndex(index)) {\n        this.setActiveItem(this.getItemByIndex(index), {}, callback);\n      } else {\n        return this.getActiveItem().index;\n      }\n    },\n\n\n    /**\n     * Convenience method to navigate to next item\n     *\n     * @param  {Number} _index -- an optional index. Used to recursively find unflitered item \n     */\n    next: function(_index) {\n      var currentIndex = _index || this.index();\n      var nextItem;\n\n      if (typeof currentIndex === 'number') {\n        nextItem = this.getItemByIndex(currentIndex + 1);\n\n        // valid index and item\n        if (nextItem) {\n\n          // proceed if not filtered. if filtered try the one after that.\n          if (!nextItem.filtered) {\n            this.index(currentIndex + 1);\n          } else {\n            this.next(currentIndex + 1);\n          }\n        }\n      }\n    },\n\n\n    /**\n     * Convenience method to navigate to previous item\n     *\n     * @param  {Number} _index -- an optional index. Used to recursively find unflitered item \n     */\n    previous: function(_index) {\n      var currentIndex = _index || this.index();\n      var previousItem;\n\n      if (typeof currentIndex === 'number') {\n        previousItem = this.getItemByIndex(currentIndex - 1);\n\n        // valid index and item\n        if (previousItem) {\n\n          // proceed if not filtered. if filtered try the one before that.\n          if (!previousItem.filtered) {\n            this.index(currentIndex - 1);            \n          } else {\n            this.previous(currentIndex - 1);\n          }\n        }\n      }\n    },\n\n\n    /**\n     * The active item object.\n     * \n     * @return {Object}\n     */\n    getActiveItem: function() {\n      return this._activeItem;\n    },\n\n\n    /**\n     * Given an item object, make it active,\n     * including updating its scroll position. \n     * \n     * @param {Object} item\n     */\n    setActiveItem: function(item, options, callback) {\n      options = options || {};\n\n      // verify item\n      if (item.id && this.getItemById(item.id)) {\n        this._scrollToItem(item, options, callback);\n      }\n    },\n\n\n    /**\n     * Iterate over each item, passing the item to a callback.\n     *\n     * this.each(function(item){ console.log(item.id) });\n     *\n     * @param {Function}\n     */\n    each: function(callback) {\n      this.applyToAllItems(callback);\n    },\n\n\n    /**\n     * Return number of items\n     * @return {Number}\n     */\n    getLength: function() {\n      return this.getItems().length;\n    },\n\n    /**\n     * Return array of all items\n     * @return {Array}\n     */\n    getItems: function() {\n      return this._items;\n    },\n\n\n    /**\n     * Given an item id, return item object with that id.\n     *\n     * @param  {string} id\n     * @return {Object}\n     */\n    getItemById: function(id) {\n      return this._itemsById[id];\n    },\n\n\n    /**\n     * Given an item index, return item object with that index.\n     *\n     * @param  {Integer} index\n     * @return {Object}\n     */\n    getItemByIndex: function(index) {\n      return this._items[index];\n    },\n\n\n    /**\n     * Return an array of items that pass an abritrary truth test.\n     *\n     * Example: this.getItemsBy(function(item){return item.data.slug=='josh_williams'})\n     *\n     * @param {Function} truthTest The function to check all items against\n     * @return {Array} Array of item objects\n     */\n    getItemsBy: function(truthTest) {\n      if (typeof truthTest !== 'function') {\n        throw new Error('You must provide a truthTest function');\n      }\n\n      return this.getItems().filter(function(item) {\n        return truthTest(item);\n      });\n    },\n\n\n    /**\n     * Returns an array of items where all the properties\n     * match an item's properties. Property tests can be\n     * any combination of:\n     *\n     * 1. Values\n     * this.getItemsWhere({index:2});\n     * this.getItemsWhere({filtered:false});\n     * this.getItemsWhere({category:'cats', width: 300});\n     *\n     * 2. Methods that return a value\n     * this.getItemsWhere({width: function(width){ return 216 + 300;}});\n     *\n     * 3. Methods that return a boolean\n     * this.getItemsWhere({index: function(index){ return index > 2; } });\n     *\n     * Mix and match:\n     * this.getItemsWehre({filtered:false, index: function(index){ return index < 30;} })\n     *\n     * @param  {Object} properties\n     * @return {Array} Array of item objects\n     */\n    getItemsWhere: function(properties) {\n      var keys,\n        items = []; // empty if properties obj not passed in\n\n      if ($.isPlainObject(properties)) {\n        keys = Object.keys(properties); // properties to check in each item\n        items = this.getItemsBy(function(item) {\n          var isMatch = keys.every(function(key) {\n            var match;\n\n            // type 3, method that runs a boolean\n            if (typeof properties[key] === 'function') {\n              match = properties[key](item[key]);\n\n              // type 2, method that runs a value\n              if (typeof match !== 'boolean') {\n                match = item[key] === match;\n              }\n\n            } else {\n              \n              // type 1, value\n              match = item[key] === properties[key];\n            }\n            return match;\n          });\n\n          if (isMatch) {\n            return item;\n          }\n        });\n      }\n\n      return items;\n    },\n\n\n    /**\n     * Array of items that are atleast partially visible\n     *\n     * @return {Array}\n     */\n    getItemsInViewport: function() {\n      return this.getItemsWhere({\n        inViewport: true\n      });\n    },\n\n\n    /**\n     * Most recently active item.  \n     * \n     * @return {Object}\n     */\n    getPreviousItem: function() {\n      return this._previousItems[0];\n    },\n\n\n    /**\n     * Array of items that were previously\n     * active, with most recently active\n     * at the front of the array. \n     * \n     * @return {Array}\n     */\n    getPreviousItems: function() {\n      return this._previousItems;\n    },\n\n\n    /**\n     * Progress of the scroll needed to activate the \n     * last item on a 0.0 - 1.0 scale.\n     *\n     * 0 means the first item isn't yet active,\n     * and 1 means the last item is active, or \n     * has already been scrolled beyond active.\n     * \n     * @return {[type]} [description]\n     */\n    getPercentScrollToLastItem: function() {\n      return this._percentScrollToLastItem || 0;\n    },\n\n\n    /**\n     * Progress of the entire scroll distance, from the start \n     * of the first item a '0', until the very end of the last\n     * item, which is '1';\n     */\n    getScrollComplete: function() {\n      return this._totalScrollComplete || 0;\n    },\n\n    /**\n     * Return an array of all filtered items.\n     * @return {Array}\n     */\n    getFilteredItems: function() {\n      return this.getItemsWhere({\n        filtered: true\n      });\n    },\n\n\n    /**\n     * Return an array of all unfiltered items.\n     * @return {Array}\n     */\n    getUnFilteredItems: function() {\n      return this.getItemsWhere({\n        filtered: false\n      });\n    },\n\n\n    /**\n     * Return an array of all items belonging to a category.\n     * \n     * @param  {String} categorySlug\n     * @return {Array}\n     */\n    getItemsByCategory: function(categorySlug) {\n      return this.getItemsWhere({\n        category: categorySlug\n      });\n    },\n\n\n    /**\n     * Return an array of all category slugs\n     * \n     * @return {Array}\n     */\n    getCategorySlugs: function() {\n      return this._categories;\n    },\n\n\n    /**\n     * Change an item's status to filtered.\n     * \n     * @param  {Object} item\n     */\n    filter: function(item) {\n      if (!item.filtered) {\n        item.filtered = true;\n        this._trigger('itemfilter', null, item);\n      }\n    },\n\n\n    /**\n     * Change an item's status to unfiltered.\n     * \n     * @param  {Object} item\n     */\n    unfilter: function(item) {\n      if (item.filtered) {\n        item.filtered = false;\n        this._trigger('itemunfilter', null, item);\n      }\n    },\n\n    /**\n     * Change all items' status to filtered.\n     * \n     * @param  {Function} callback\n     */\n    filterAll: function(callback) {\n      callback = ($.isFunction(callback)) ? callback.bind(this) : $.noop;\n      var filterFnc = this.filter.bind(this);\n      this.getItems().forEach(filterFnc);\n    },\n\n    /**\n     * Change all items' status to unfiltered.\n     * \n     * @param  {Function} callback\n     */\n    unfilterAll: function(callback) {\n      callback = ($.isFunction(callback)) ? callback.bind(this) : $.noop;\n      var unfilterFnc = this.unfilter.bind(this);\n      this.getItems().forEach(unfilterFnc);\n    },\n\n\n    /**\n     * Filter items that pass an abritrary truth test. This is a light \n     * wrapper around `getItemsBy()` and `filter()`.\n     *\n     * Example: this.filterBy(function(item){return item.data.last_name === 'williams'})\n     *\n     * @param {Function} truthTest The function to check all items against\n     * @param  {Function} callback\n     */\n    filterBy: function(truthTest, callback) {\n      callback = ($.isFunction(callback)) ? callback.bind(this) : $.noop;\n      var filterFnc = this.filter.bind(this);\n      this.getItemsBy(truthTest).forEach(filterFnc);\n      callback();\n    },\n\n\n    /**\n     * Filter items where all the properties match an item's properties. This \n     * is a light wrapper around `getItemsWhere()` and `filter()`. See `getItemsWhere()`\n     * for more options and examples.\n     * \n     * Example: this.filterWhere({index:2})\n     *\n     * @param {Function} truthTest The function to check all items against\n     * @param  {Function} callback\n     */\n    filterWhere: function(properties, callback) {\n      callback = ($.isFunction(callback)) ? callback.bind(this) : $.noop;\n      var filterFnc = this.filter.bind(this);\n      this.getItemsWhere(properties).forEach(filterFnc);\n      callback();\n    },\n\n\n    /**\n     * Whether or not any of the item objects are active.\n     *\n     * @return {Boolean}\n     */\n    isContainerActive: function() {\n      return this._isActive;\n    },\n\n\n    /**\n     * Disable scroll updates. This is useful in the\n     * rare case when you want to manipulate the page\n     * but not have ScrollStory continue to check\n     * positions, fire events, etc. Usually a `disable`\n     * is temporary and followed by an `enable`.\n     */\n    disable: function() {\n      this.options.enabled = false;\n    },\n    \n    \n    /**\n     * Enable scroll updates\n     */\n    enable: function() {\n      this.options.enabled = true;\n    },\n\n\n    /**\n     * Update trigger offset. This is useful if a client\n     * app needs to, post-instantiation, change the trigger\n     * point, like after a window resize. \n     * \n     * @param  {Number} offset\n     */\n    updateTriggerOffset: function(offset) {\n      this.options.triggerOffset = offset;\n      this.updateOffsets();\n      this._trigger('triggeroffsetupdate', null, offsetToPx(offset));\n    },\n\n\n    /**\n     * Update scroll offset. This is useful if a client\n     * app needs to, post-instantiation, change the scroll\n     * offset, like after a window resize. \n     * @param  {Number} offset\n     */\n    updateScrollOffset: function(offset) {\n      this.options.scrollOffset = offset;\n      this.updateOffsets();\n      this._trigger('scrolloffsetupdate', null, offsetToPx(offset));\n    },\n\n\n    /**\n     * Determine which item should be active,\n     * and then make it so.\n     */\n    _setActiveItem: function() {\n\n      // top of the container is above the trigger point and the bottom is still below trigger point. \n      var containerInActiveArea = (this._distanceToFirstItemTopOffset <= 0 && (Math.abs(this._distanceToOffset) - this._height) < 0);\n\n      // only check items that aren't filtered\n      var items = this.getItemsWhere({\n        filtered: false\n      });\n\n      var activeItem;\n      items.forEach(function(item) {\n\n        // item has to have crossed the trigger offset\n        if (item.adjustedDistanceToOffset <= 0) {\n          if (!activeItem) {\n            activeItem = item;\n          } else {\n\n            // closer to trigger point than previously found item?\n            if (activeItem.adjustedDistanceToOffset < item.adjustedDistanceToOffset) {\n              activeItem = item;\n            }\n          }\n        }\n      });\n\n      // double check conditions around an active item\n      if (activeItem && !containerInActiveArea && this.options.disablePastLastItem) {\n        activeItem = false;\n\n        // not yet scrolled in, but auto-activate is set to true\n      } else if (!activeItem && this.options.autoActivateFirstItem && items.length > 0) {\n        activeItem = items[0];\n      }\n\n      if (activeItem) {\n        this._focusItem(activeItem);\n\n        // container\n        if (!this._isActive) {\n          this._isActive = true;\n          this._trigger('containeractive');\n        }\n\n      } else {\n        this._blurAllItems();\n\n        // container\n        if (this._isActive) {\n          this._isActive = false;\n          this._trigger('containerinactive');\n        }\n      }\n    },\n\n\n    /**\n     * Scroll to an item, making it active.\n     * \n     * @param  {Object}   item\n     * @param  {Object}   opts\n     * @param  {Function} callback  \n     */\n    _scrollToItem: function(item, opts, callback) {\n      callback = ($.isFunction(callback)) ? callback.bind(this) : $.noop;\n\n      /**\n       * Allows global scroll options to be overridden\n       * in one of two ways:\n       *\n       * 1. Higher priority: Passed in to scrollToItem directly via opts obj.\n       * 2. Lower priority: options set as an item.* property\n       */\n      opts = $.extend(true, {\n        // prefer item.scrollOffset over this.options.scrollOffset\n        scrollOffset: (item.scrollOffset !== false) ? offsetToPx(item.scrollOffset) : offsetToPx(this.options.scrollOffset),\n        speed: this.options.speed,\n        easing: this.options.easing\n      }, opts);\n\n\n      // because we animate to body and html for maximum compatiblity, \n      // we only want the callback to fire once. jQuery will call it \n      // once for each element otherwise\n      var debouncedCallback = debounce(callback, 100);\n\n      // position to travel to\n      var scrolllTop = item.el.offset().top - offsetToPx(opts.scrollOffset);\n      $('html, body').stop(true).animate({\n          scrollTop: scrolllTop\n      }, opts.speed, opts.easing, debouncedCallback);\n    },\n\n\n    /**\n     * Excecute a callback function that expects an\n     * item as its paramamter for each items.\n     *\n     * Optionally, a item or array of items of exceptions\n     * can be passed in. They'll not call the callback.\n     *\n     * @param  {Function} callback         Method to call, and pass in exepctions\n     * @param  {Object/Array}   exceptions\n     */\n    applyToAllItems: function(callback, exceptions) {\n      exceptions = ($.isArray(exceptions)) ? exceptions : [exceptions];\n      callback = ($.isFunction(callback)) ? callback.bind(this) : $.noop;\n\n      var items = this.getItems();\n      var i = 0;\n      var length = items.length;\n      var item;\n\n      for (i = 0; i < length; i++) {\n        item = items[i];\n        if (exceptions.indexOf(item) === -1) {\n          callback(item, i);\n        }\n      }\n    },\n\n\n    /**\n     * Unfocus all items.\n     *\n     * @param  {Object/Array} exceptions item or array of items to not blur\n     */\n    _blurAllItems: function(exceptions) {\n      this.applyToAllItems(this._blurItem.bind(this), exceptions);\n\n      if (!exceptions) {\n        this._activeItem = undefined;\n      }\n    },\n\n    /**\n     * Unfocus an item\n     * @param  {Object}\n     */\n    _blurItem: function(item) {\n      if (item.active) {\n        item.active = false;\n        this._trigger('itemblur', null, item);\n      }\n    },\n\n\n    /**\n     * Given an item, give it focus. Focus is exclusive\n     * so we unfocus any other item.\n     *\n     * @param  {Object} item object\n     */\n    _focusItem: function(item) {\n      if (!item.active && !item.filtered) {\n        this._blurAllItems(item);\n\n        // make active\n        this._activeItem = item;\n        item.active = true;\n\n        // notify clients of changes\n        this._trigger('itemfocus', null, item);\n      }\n    },\n\n\n    /**\n     * Iterate through items and update their top offset.\n     * Useful if items have been added, removed,\n     * repositioned externally, and after window resize\n     *\n     * Based on:\n     * http://javascript.info/tutorial/coordinates\n     * http://stackoverflow.com/questions/123999/how-to-tell-if-a-dom-element-is-visible-in-the-current-viewport/7557433#7557433\n     */\n    updateOffsets: function() {\n      var bodyElem = document.body;\n      var docElem = document.documentElement;\n\n      var scrollTop = window.pageYOffset || docElem.scrollTop || bodyElem.scrollTop;\n      var clientTop = docElem.clientTop || bodyElem.clientTop || 0;\n      var items = this.getItems();\n      var i = 0;\n      var length = items.length;\n      var item;\n      var box;\n\n      // individual items\n      for (i = 0; i < length; i++) {\n        item = items[i];\n        box = item.el[0].getBoundingClientRect();\n\n        // add or update item properties\n        item.width = box.width;\n        item.height = box.height;\n        item.topOffset = box.top + scrollTop - clientTop;\n      }\n\n      // container\n      box = this.el.getBoundingClientRect();\n      this._height = box.height;\n      this._width = box.width;\n      this._topOffset = box.top + scrollTop - clientTop;\n\n      this._trigger('updateoffsets');\n    },\n\n    _updateScrollPositions: function() {\n      var bodyElem = document.body;\n      var docElem = document.documentElement;\n      var scrollTop = window.pageYOffset || docElem.scrollTop || bodyElem.scrollTop;\n      var wHeight = window.innerHeight || docElem.clientHeight;\n      var wWidth = window.innerWidth || docElem.clientWidth;\n      var triggerOffset = offsetToPx(this.options.triggerOffset);\n\n\n      // update item scroll positions\n      var items = this.getItems();\n      var length = items.length;\n      var lastItem = items[length -1];\n      var i = 0;\n      var item;\n      var rect;\n      var previouslyInViewport;\n\n      // track total scroll across all items\n      var totalScrollComplete = 0;\n\n      for (i = 0; i < length; i++) {\n        item = items[i];\n        rect = item.el[0].getBoundingClientRect();\n        item.distanceToOffset = Math.floor(item.topOffset - scrollTop - triggerOffset); // floor to prevent some off-by-fractional px in determining active item\n        item.adjustedDistanceToOffset = (item.triggerOffset === false) ? item.distanceToOffset : item.topOffset - scrollTop - item.triggerOffset;\n\n        // percent through this item's active scroll. expressed 0 - 1;\n        if (item.distanceToOffset >= 0) {\n          item.percentScrollComplete = 0;\n        } else if (Math.abs(item.distanceToOffset) >= rect.height){\n          item.percentScrollComplete = 1;\n        } else {\n          item.percentScrollComplete = Math.abs(item.distanceToOffset) / rect.height;\n        }\n\n        // track percent scroll \n        totalScrollComplete = totalScrollComplete + item.percentScrollComplete;\n\n        // track viewport status\n        previouslyInViewport = item.inViewport;\n        item.inViewport = rect.bottom > 0 && rect.right > 0 && rect.left < wWidth && rect.top < wHeight;\n        item.fullyInViewport = rect.top >= 0 && rect.left >= 0 && rect.bottom <= wHeight && rect.right <= wWidth;\n\n        if (item.inViewport && !previouslyInViewport) {\n          this._trigger('itementerviewport', null, item);\n        } else if (!item.inViewport && previouslyInViewport) {\n          this._trigger('itemexitviewport', null, item);\n        }\n      }\n\n      // update container scroll position\n      this._distanceToFirstItemTopOffset = items[0].adjustedDistanceToOffset;\n\n      // takes into account other elements that might make the top of the \n      // container different than the topoffset of the first item.\n      this._distanceToOffset = this._topOffset - scrollTop - triggerOffset;\n\n\n      // percent of the total scroll needed to activate the last item\n      var percentScrollToLastItem = 0;\n      if (this._distanceToOffset < 0) {\n        percentScrollToLastItem = 1 - (lastItem.distanceToOffset / (this._height - lastItem.height));\n        percentScrollToLastItem = (percentScrollToLastItem < 1) ? percentScrollToLastItem : 1; // restrict range\n      }\n\n      this._percentScrollToLastItem = percentScrollToLastItem;\n\n      this._totalScrollComplete = totalScrollComplete / length;\n    },\n\n\n    /**\n     * Add items to the running list given any of the\n     * following inputs:\n     *\n     * 1. jQuery selection. Items will be generated\n     * from the selection, and any data-* attributes\n     * will be added to the item's data object.\n     *\n     * 2. A string selector to search for elements\n     * within our container. Items will be generated\n     * from that selection, and any data-* attributes\n     * will be added to the item's data object.\n     *\n     * 3. Array of objects. All needed markup will\n     * be generated, and the data in each object will\n     * be added to the item's data object.\n     *\n     * 4. If no 'items' param, we search for items\n     * using the options.contentSelector string.\n     *\n     *\n     * TODO: ensure existing items aren't re-added.\n     * This is expecially important for the empty items\n     * option, and will give us the ability to do\n     * infinite scrolls, etc.\n     *\n     * @param {jQuery Object/String/Array} items\n     */\n    addItems: function(items, opts) {\n\n      opts = $.extend(true, {\n        handleRepaint: true\n      }, opts);\n\n      // use an existing jQuery selection\n      if (items instanceof $) {\n        this._prepItemsFromSelection(items);\n\n        // a custom selector to use within our container\n      } else if (typeof items === 'string') {\n        this._prepItemsFromSelection(this.$el.find(items));\n\n        // array objects, which will be used to create markup\n      } else if ($.isArray(items)) {\n        this._prepItemsFromData(items);\n\n        // search for elements with the default selector\n      } else {\n        this._prepItemsFromSelection(this.$el.find(this.options.contentSelector));\n      }\n\n      // after instantiation and any addItems, we must have \n      // atleast one valid item. If not, plugin is misconfigured.\n      if (this.getItems().length < 1) {\n        throw new Error('addItems found no valid items.');\n      }\n\n      if (opts.handleRepaint) {\n        this._handleRepaint();\n      }\n    },\n\n    /**\n     * Remove any classes added during\n     * use and unbind all events.\n     */\n    destroy: function(removeMarkup) {\n      removeMarkup = removeMarkup || false;\n\n      if(removeMarkup){\n        this.each(function(item){\n          item.el.remove();\n        });\n      }\n\n      // cleanup dom / events and \n      // run any user code\n      this._trigger('destroy');\n\n      // plugin wrapper disallows multiple scrollstory\n      // instances on the same element. after a destory,\n      // allow plugin to reattach to this element.\n       var containerData = this.$el.data();\n       containerData['plugin_' + pluginName] = null;\n\n      // TODO: destroy the *instance*?\n    },\n\n\n    /**\n     * Update items' scroll positions and \n     * determine which one is active based \n     * on those positions. Useful during\n     * scrolls, resizes and other events\n     * that repaint the page. \n     *\n     * updateOffsets should be used \n     * with caution, as it's CPU intensive,\n     * and only useful it item sizes or\n     * scrollOffsets have changed.\n     * \n     * @param  {Boolean} updateOffsets \n     * @return {[type]} [description]\n     */\n    _handleRepaint: function(updateOffsets) {\n      updateOffsets = (updateOffsets === false) ? false : true;\n      \n      if (updateOffsets) {\n        this.updateOffsets(); // must be called first\n      }\n\n      this._updateScrollPositions(); // must be called second\n      this._setActiveItem(); // must be called third\n    },\n\n\n    /**\n     * Keep state correct while scrolling\n     */\n    _handleScroll: function() {\n      if (this.options.enabled) {\n        this._handleRepaint(false);\n        this._trigger('containerscroll');\n      }\n    },\n\n    /**\n     * Keep state correct while resizing\n     */\n    _handleResize: function() {\n      winHeight = $window.height();\n      \n      if (this.options.enabled && this.options.autoUpdateOffsets) {\n\n        if (offsetIsAPercentage(this.options.triggerOffset)) {\n          this.updateTriggerOffset(this.options.triggerOffset);\n        }\n\n        if (offsetIsAPercentage(this.options.scrollOffset)) {\n          this.updateScrollOffset(this.options.scrollOffset);\n        }\n\n        this._debouncedHandleRepaint();\n        this._trigger('containerresize');\n      }\n    },\n\n    // Handlers for public events that maintain state\n    // of the ScrollStory instance.\n\n    _onSetup: function() {\n      this.$el.addClass(pluginName);\n    },\n\n    _onDestroy: function() {\n\n      // remove events\n      this.$el.off(eventNameSpace);\n      $window.off(eventNameSpace);\n\n      // item classes\n      var itemClassesToRemove = ['scrollStoryItem', 'inviewport', 'active', 'filtered'].join(' ');\n      this.each(function(item){\n        item.el.removeClass(itemClassesToRemove);\n      });\n\n      // container classes\n      this.$el.removeClass(function(i, classNames){\n        var classNamesToRemove = [];\n        classNames.split(' ').forEach(function(c){\n          if (c.lastIndexOf(pluginName) === 0 ){\n            classNamesToRemove.push(c);\n          }\n        });\n        return classNamesToRemove.join(' ');\n      });\n\n      this.$trigger.remove();\n    },\n\n    _onContainerActive: function() {\n      this.$el.addClass(pluginName + 'Active');\n    },\n\n    _onContainerInactive: function() {\n      this.$el.removeClass(pluginName + 'Active');\n    },\n\n    _onItemFocus: function(ev, item) {\n      item.el.addClass('active');\n      this._manageContainerClasses('scrollStoryActiveItem-',item.id);\n\n      // trigger catgory change if not previously active or\n      // this item's category is different from the last\n      if (item.category) {\n        if ( (this.getPreviousItem() && this.getPreviousItem().category !== item.category) || !this.isContainerActive()) {\n          this._trigger('categoryfocus', null, item.category);\n\n          if (this.getPreviousItem()) {\n            this._trigger('categoryblur', null, this.getPreviousItem().category);\n          }\n        }\n      }\n    },\n\n    _onItemBlur: function(ev, item) {\n      this._previousItems.unshift(item);\n      item.el.removeClass('active');\n    },\n\n    _onItemEnterViewport: function(ev, item) {\n      item.el.addClass('inviewport');\n    },\n\n    _onItemExitViewport: function(ev, item) {\n      item.el.removeClass('inviewport');\n    },\n\n    _onItemFilter: function(ev, item) {\n      item.el.addClass('filtered');\n      if (this.options.autoUpdateOffsets) {\n        this._debouncedHandleRepaint();\n      }\n    },\n\n    _onItemUnfilter: function(ev, item) {\n      item.el.removeClass('filtered');\n      if (this.options.autoUpdateOffsets) {\n        this._debouncedHandleRepaint();\n      }\n    },\n\n    _onCategoryFocus: function(ev, category) {\n      this._manageContainerClasses('scrollStoryActiveCategory-',category);\n    },\n\n    _onTriggerOffsetUpdate: function(ev, offset) {\n      this.$trigger.css({\n        top: offset + 'px'\n      });\n    },\n\n\n\n    /**\n     * Given a prefix string like 'scrollStoryActiveCategory-',\n     * and a value like 'fruit', add 'scrollStoryActiveCategory-fruit'\n     * class to the containing element after removing any other \n     * 'scrollStoryActiveCategory-*' classes\n     * @param  {[type]} prefix [description]\n     * @param  {[type]} value  [description]\n     * @return {[type]}        [description]\n     */\n    _manageContainerClasses: function(prefix, value) {\n      this.$el.removeClass(function(index, classes){\n        return classes.split(' ').filter(function(c) {\n            return c.lastIndexOf(prefix, 0) === 0;\n        }).join(' ');\n      });\n      this.$el.addClass(prefix+value);\n    },\n\n\n    /**\n     * Given a jQuery selection, add those elements\n     * to the internal items array.\n     *\n     * @param  {Object} $jQuerySelection\n     */\n    _prepItemsFromSelection: function($selection) {\n      var that = this;\n      $selection.each(function() {\n        that._addItem({}, $(this));\n      });\n    },\n\n\n    /**\n     * Given array of data, append markup and add\n     * data to internal items array.\n     * @param  {Array} items\n     */\n    _prepItemsFromData: function(items) {\n      var that = this;\n\n      // drop period from the default selector, so we can \n      // add it to the class attr in markup\n      var selector = this.options.contentSelector.replace(/\\./g, '');\n\n      var frag = document.createDocumentFragment();\n      items.forEach(function(data) {\n        var $item = $('<div class=\"' + selector + '\"></div>');\n        that._addItem(data, $item);\n        frag.appendChild($item.get(0));\n      });\n\n      this.$el.append(frag);\n    },\n\n\n    /**\n     * Given item user data, and an aleady appended\n     * jQuery object, create an item for internal items array.\n     *\n     * @param {Object} data\n     * @param {jQuery Object} $el\n     */\n    _addItem: function(data, $el) {\n      var domData = $el.data();\n\n      var item = {\n        index: this._items.length,\n        el: $el,\n        // id is from markup id attribute, data or dynamically generated\n        id: $el.attr('id') ? $el.attr('id') : (data.id) ? data.id : 'story' + instanceCounter + '-' + this._items.length,\n\n        // item's data is from client data or data-* attrs. prefer data-* attrs over client data.\n        data: $.extend({}, data, domData),\n\n        category: domData.category || data.category, // string. optional category slug this item belongs to. prefer data-category attribute\n        tags: data.tags || [], // optional tag or tags for this item. Can take an array of string, or a cvs string that'll be converted into array of strings.\n        scrollStory: this, // reference to this instance of scrollstory\n\n        // in-focus item\n        active: false,\n\n        // has item been filtered\n        filtered: false,\n\n        // on occassion, the scrollToItem() offset may need to be adjusted for a\n        // particular item. this overrides this.options.scrollOffset set on instantiation\n        scrollOffset: false,\n\n        // on occassion we want to trigger an item at a non-standard offset.\n        triggerOffset: false,\n\n        // if any part is viewable in the viewport.\n        inViewport: false\n\n      };\n\n      // ensure id exist in dom\n      if (!$el.attr('id')) {\n        $el.attr('id', item.id);\n      }\n\n      $el.addClass('scrollStoryItem');\n\n      // global record\n      this._items.push(item);\n\n      // quick lookup\n      this._itemsById[item.id] = item;\n\n      this._trigger('itembuild', null, item);\n\n      // An item's category is saved after the the itembuild event\n      // to allow for user code to specify a category client-side in \n      // that event callback or handler.\n      if (item.category && this._categories.indexOf(item.category) === -1) {\n        this._categories.push(item.category);\n      }\n\n      // this._tags.push(item.tags);\n    },\n\n\n    /**\n     * Manage callbacks and event dispatching.\n     *\n     * Based very heavily on jQuery UI's implementaiton\n     * https://github.com/jquery/jquery-ui/blob/9d0f44fd7b16a66de1d9b0d8c5e4ab954d83790f/ui/widget.js#L492\n     *\n     * @param  {String} eventType\n     * @param  {Object} event\n     * @param  {Object} data\n     */\n    _trigger: function(eventType, event, data) {\n      var callback = this.options[eventType];\n      var prop, orig;\n\n      if ($.isFunction(callback)) {\n        data = data || {};\n\n        event = $.Event(event);\n        event.target = this.el;\n        event.type = eventType;\n\n        // copy original event properties over to the new event\n        orig = event.originalEvent;\n        if (orig) {\n          for (prop in orig) {\n            if (!(prop in event)) {\n              event[prop] = orig[prop];\n            }\n          }\n        }\n\n        // fire event\n        this.$el.trigger(event, data);\n\n        // call the callback\n        var boundCb = this.options[eventType].bind(this);\n        boundCb(event, data);\n      }\n    }\n  }; // end plugin.prototype\n\n\n  /**\n   * Debounced version of prototype methods\n   */\n  ScrollStory.prototype.debouncedUpdateOffsets = debounce(ScrollStory.prototype.updateOffsets, 100);\n  ScrollStory.prototype._debouncedHandleRepaint = debounce(ScrollStory.prototype._handleRepaint, 100);\n\n\n\n  // A really lightweight plugin wrapper around the constructor,\n  // preventing multiple instantiations\n  $.fn[pluginName] = function(options) {\n    return this.each(function() {\n      if (!$.data(this, 'plugin_' + pluginName)) {\n        $.data(this, 'plugin_' + pluginName, new ScrollStory(this, options));\n      }\n    });\n  };\n}));","/* eslint-env browser */\n/* globals $ */\nimport 'scrollstory/jquery.scrollstory';\n\nfunction loadItem(item) {\n  item.el.find('.video-container').addClass('fixed');\n  const video = item.el.find('video').get(0);\n  video.play();\n}\n\n// code needed to bootstrap editor preview\n$(document).ready(function() {\n  const $story = $('#scrollytelling');\n\n  const scrollStory = $story\n    .scrollStory({\n      contentSelector: '.part',\n      triggerOffset: 0,\n    })\n    .data('plugin_scrollStory');\n\n  const storyItems = scrollStory.getItems();\n  window.draftItem = storyItems[0];\n  loadItem(window.draftItem);\n});\n\n// code needed to refresh editor preview\nwindow.refresh = function() {\n  loadItem(window.draftItem);\n};\n","(function() { module.exports = window[\"jQuery\"]; }());"],"sourceRoot":""}