{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./node_modules/blueimp-gallery/js/blueimp-gallery.js","webpack:///./node_modules/blueimp-gallery/js/blueimp-helper.js","webpack:///./node_modules/scrollstory/jquery.scrollstory.js","webpack:///./src/client/items/HorizontalSlideshow.js","webpack:///external \"jQuery\""],"names":[],"mappings":";QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;AClFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,CAAC;AACD;AACA,MAAM,IAA0C;AAChD;AACA,IAAI,iCAAO,CAAC,kGAAkB,CAAC,oCAAE,OAAO;AAAA;AAAA;AAAA,oGAAC;AACzC,GAAG,MAAM,EAIN;AACH,CAAC;AACD;;AAEA;AACA;AACA;AACA;AACA,aAAa,eAAe;AAC5B,aAAa,OAAO;AACpB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,WAAW,mBAAmB,EAAE;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,cAAc;AACpD;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;;AAEL;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,MAAM;AACvB,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,iBAAiB,WAAW;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,2CAA2C,SAAS;AACpD;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,SAAS;AACtD;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,cAAc;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA,CAAC;;;;;;;;;;;;ACv7CD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,CAAC;AACD;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,EAAE;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,GAAG;;AAEH,MAAM,IAA0C;AAChD,IAAI,mCAAO;AACX;AACA,KAAK;AAAA,oGAAC;AACN,GAAG,MAAM,EAGN;AACH,CAAC;;;;;;;;;;;;AC3MD;AACA;AACA;AACA,mCAAmC;AACnC;;AAEA;AACA,MAAM,IAA0C;AAChD,IAAI,iCAAO,CAAC,2CAAQ,CAAC,oCAAE,OAAO;AAAA;AAAA;AAAA,oGAAC;AAC/B,GAAG,MAAM,EAEN;AACH,CAAC;;AAED;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA,mCAAmC;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,cAAc;AAC5B,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA,8BAA8B;;AAE9B;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,QAAQ;AACtC;AACA,oBAAoB;AACpB;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA,SAAS;AACT;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;;AAGL;AACA;AACA;AACA,gBAAgB,OAAO;AACvB,gBAAgB,SAAS;AACzB,gBAAgB,OAAO;AACvB;AACA;AACA;AACA,yDAAyD;AACzD,OAAO;AACP;AACA;AACA,KAAK;;;AAGL;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,KAAK;;;AAGL;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,yC;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,KAAK;;;AAGL;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,KAAK;;;AAGL;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;;AAGL;AACA;AACA;AACA,gCAAgC,uBAAuB;AACvD;AACA,eAAe;AACf;AACA;AACA;AACA,KAAK;;;AAGL;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,KAAK;;;AAGL;AACA;AACA;AACA,gBAAgB,OAAO;AACvB,gBAAgB;AAChB;AACA;AACA;AACA,KAAK;;;AAGL;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB,gBAAgB;AAChB;AACA;AACA;AACA,KAAK;;;AAGL;AACA;AACA;AACA,+CAA+C,uCAAuC;AACtF;AACA,eAAe,SAAS;AACxB,gBAAgB,MAAM;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP,KAAK;;;AAGL;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,QAAQ;AACnC,2BAA2B,eAAe;AAC1C,2BAA2B,4BAA4B;AACvD;AACA;AACA,2BAA2B,uBAAuB,oBAAoB;AACtE;AACA;AACA,2BAA2B,uBAAuB,kBAAkB,EAAE,EAAE;AACxE;AACA;AACA,2BAA2B,uCAAuC,oBAAoB,EAAE;AACxF;AACA,gBAAgB,OAAO;AACvB,gBAAgB,MAAM;AACtB;AACA;AACA;AACA,mBAAmB;;AAEnB;AACA,uCAAuC;AACvC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,aAAa;;AAEb;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA,KAAK;;;AAGL;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;;;AAGL;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,KAAK;;;AAGL;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,KAAK;;;AAGL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA,KAAK;;;AAGL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;;;AAGL;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;;;AAGL;AACA;AACA;AACA,gBAAgB,OAAO;AACvB,gBAAgB;AAChB;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;;;AAGL;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,KAAK;;;AAGL;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;;AAGL;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA,KAAK;;;AAGL;AACA;AACA;AACA;AACA,6CAA6C,0CAA0C;AACvF;AACA,eAAe,SAAS;AACxB,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;;AAGL;AACA;AACA;AACA;AACA;AACA,kCAAkC,QAAQ;AAC1C;AACA,eAAe,SAAS;AACxB,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;;AAGL;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,KAAK;;;AAGL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;;AAGL;AACA;AACA;AACA;AACA;AACA,KAAK;;;AAGL;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA,KAAK;;;AAGL;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA,KAAK;;;AAGL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;;AAEP;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;;AAGL;AACA;AACA;AACA,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB,gBAAgB,SAAS;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;;AAGP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;;;AAGL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,SAAS;AACzB,gBAAgB,aAAa;AAC7B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;AACA,KAAK;;;AAGL;AACA;AACA;AACA,gBAAgB,aAAa;AAC7B;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;;AAGL;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;;AAGL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,YAAY;AAC7B;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,iBAAiB,YAAY;AAC7B;AACA;AACA,uFAAuF;AACvF;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,8FAA8F;AAC9F;;AAEA;;AAEA;AACA,KAAK;;;AAGL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,2BAA2B;AAC1C;AACA;;AAEA;AACA;AACA,OAAO;;AAEP;AACA;AACA;;AAEA;AACA,OAAO;AACP;;AAEA;AACA,OAAO;AACP;;AAEA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;;AAGL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB,gBAAgB,OAAO;AACvB;AACA;AACA;;AAEA;AACA,6BAA6B;AAC7B;;AAEA,oCAAoC;AACpC,4BAA4B;AAC5B,KAAK;;;AAGL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,OAAO;;AAEP;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,OAAO;AACP,KAAK;;;;AAIL;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA,KAAK;;;AAGL;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA,wBAAwB;AACxB,OAAO;AACP,KAAK;;;AAGL;AACA;AACA;AACA,gBAAgB,MAAM;AACtB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA,KAAK;;;AAGL;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,cAAc;AAC7B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,yBAAyB;;AAEzB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;;AAGL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;;;AAGJ;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,G;;;;;;;;;;;;ACxiDD;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACwC;AACiB;;AAEzD;AACA;;AAEA,EAAE,yEAAO;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA,CAAC;;;;;;;;;;;;ACrCD,wB","file":"HorizontalSlideshow.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/client/items/HorizontalSlideshow.js\");\n","/*\n * blueimp Gallery JS\n * https://github.com/blueimp/Gallery\n *\n * Copyright 2013, Sebastian Tschan\n * https://blueimp.net\n *\n * Swipe implementation based on\n * https://github.com/bradbirdsall/Swipe\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n */\n\n/* global define, DocumentTouch */\n\n/* eslint-disable no-param-reassign */\n\n;(function(factory) {\n  'use strict'\n  if (typeof define === 'function' && define.amd) {\n    // Register as an anonymous AMD module:\n    define(['./blueimp-helper'], factory)\n  } else {\n    // Browser globals:\n    window.blueimp = window.blueimp || {}\n    window.blueimp.Gallery = factory(window.blueimp.helper || window.jQuery)\n  }\n})(function($) {\n  'use strict'\n\n  /**\n   * Gallery constructor\n   *\n   * @class\n   * @param {Array|NodeList} list Gallery content\n   * @param {object} [options] Gallery options\n   * @returns {object} Gallery object\n   */\n  function Gallery(list, options) {\n    if (document.body.style.maxHeight === undefined) {\n      // document.body.style.maxHeight is undefined on IE6 and lower\n      return null\n    }\n    if (!this || this.options !== Gallery.prototype.options) {\n      // Called as function instead of as constructor,\n      // so we simply return a new instance:\n      return new Gallery(list, options)\n    }\n    if (!list || !list.length) {\n      this.console.log(\n        'blueimp Gallery: No or empty list provided as first argument.',\n        list\n      )\n      return\n    }\n    this.list = list\n    this.num = list.length\n    this.initOptions(options)\n    this.initialize()\n  }\n\n  $.extend(Gallery.prototype, {\n    options: {\n      // The Id, element or querySelector of the gallery widget:\n      container: '#blueimp-gallery',\n      // The tag name, Id, element or querySelector of the slides container:\n      slidesContainer: 'div',\n      // The tag name, Id, element or querySelector of the title element:\n      titleElement: 'h3',\n      // The class to add when the gallery is visible:\n      displayClass: 'blueimp-gallery-display',\n      // The class to add when the gallery controls are visible:\n      controlsClass: 'blueimp-gallery-controls',\n      // The class to add when the gallery only displays one element:\n      singleClass: 'blueimp-gallery-single',\n      // The class to add when the left edge has been reached:\n      leftEdgeClass: 'blueimp-gallery-left',\n      // The class to add when the right edge has been reached:\n      rightEdgeClass: 'blueimp-gallery-right',\n      // The class to add when the automatic slideshow is active:\n      playingClass: 'blueimp-gallery-playing',\n      // The class for all slides:\n      slideClass: 'slide',\n      // The slide class for loading elements:\n      slideLoadingClass: 'slide-loading',\n      // The slide class for elements that failed to load:\n      slideErrorClass: 'slide-error',\n      // The class for the content element loaded into each slide:\n      slideContentClass: 'slide-content',\n      // The class for the \"toggle\" control:\n      toggleClass: 'toggle',\n      // The class for the \"prev\" control:\n      prevClass: 'prev',\n      // The class for the \"next\" control:\n      nextClass: 'next',\n      // The class for the \"close\" control:\n      closeClass: 'close',\n      // The class for the \"play-pause\" toggle control:\n      playPauseClass: 'play-pause',\n      // The list object property (or data attribute) with the object type:\n      typeProperty: 'type',\n      // The list object property (or data attribute) with the object title:\n      titleProperty: 'title',\n      // The list object property (or data attribute) with the object alt text:\n      altTextProperty: 'alt',\n      // The list object property (or data attribute) with the object URL:\n      urlProperty: 'href',\n      // The list object property (or data attribute) with the object srcset URL(s):\n      srcsetProperty: 'urlset',\n      // The gallery listens for transitionend events before triggering the\n      // opened and closed events, unless the following option is set to false:\n      displayTransition: true,\n      // Defines if the gallery slides are cleared from the gallery modal,\n      // or reused for the next gallery initialization:\n      clearSlides: true,\n      // Defines if images should be stretched to fill the available space,\n      // while maintaining their aspect ratio (will only be enabled for browsers\n      // supporting background-size=\"contain\", which excludes IE < 9).\n      // Set to \"cover\", to make images cover all available space (requires\n      // support for background-size=\"cover\", which excludes IE < 9):\n      stretchImages: false,\n      // Toggle the controls on pressing the Return key:\n      toggleControlsOnReturn: true,\n      // Toggle the controls on slide click:\n      toggleControlsOnSlideClick: true,\n      // Toggle the automatic slideshow interval on pressing the Space key:\n      toggleSlideshowOnSpace: true,\n      // Navigate the gallery by pressing left and right on the keyboard:\n      enableKeyboardNavigation: true,\n      // Close the gallery on pressing the Esc key:\n      closeOnEscape: true,\n      // Close the gallery when clicking on an empty slide area:\n      closeOnSlideClick: true,\n      // Close the gallery by swiping up or down:\n      closeOnSwipeUpOrDown: true,\n      // Emulate touch events on mouse-pointer devices such as desktop browsers:\n      emulateTouchEvents: true,\n      // Stop touch events from bubbling up to ancestor elements of the Gallery:\n      stopTouchEventsPropagation: false,\n      // Hide the page scrollbars:\n      hidePageScrollbars: true,\n      // Stops any touches on the container from scrolling the page:\n      disableScroll: true,\n      // Carousel mode (shortcut for carousel specific options):\n      carousel: false,\n      // Allow continuous navigation, moving from last to first\n      // and from first to last slide:\n      continuous: true,\n      // Remove elements outside of the preload range from the DOM:\n      unloadElements: true,\n      // Start with the automatic slideshow:\n      startSlideshow: false,\n      // Delay in milliseconds between slides for the automatic slideshow:\n      slideshowInterval: 5000,\n      // The starting index as integer.\n      // Can also be an object of the given list,\n      // or an equal object with the same url property:\n      index: 0,\n      // The number of elements to load around the current index:\n      preloadRange: 2,\n      // The transition speed between slide changes in milliseconds:\n      transitionSpeed: 400,\n      // The transition speed for automatic slide changes, set to an integer\n      // greater 0 to override the default transition speed:\n      slideshowTransitionSpeed: undefined,\n      // The event object for which the default action will be canceled\n      // on Gallery initialization (e.g. the click event to open the Gallery):\n      event: undefined,\n      // Callback function executed when the Gallery is initialized.\n      // Is called with the gallery instance as \"this\" object:\n      onopen: undefined,\n      // Callback function executed when the Gallery has been initialized\n      // and the initialization transition has been completed.\n      // Is called with the gallery instance as \"this\" object:\n      onopened: undefined,\n      // Callback function executed on slide change.\n      // Is called with the gallery instance as \"this\" object and the\n      // current index and slide as arguments:\n      onslide: undefined,\n      // Callback function executed after the slide change transition.\n      // Is called with the gallery instance as \"this\" object and the\n      // current index and slide as arguments:\n      onslideend: undefined,\n      // Callback function executed on slide content load.\n      // Is called with the gallery instance as \"this\" object and the\n      // slide index and slide element as arguments:\n      onslidecomplete: undefined,\n      // Callback function executed when the Gallery is about to be closed.\n      // Is called with the gallery instance as \"this\" object:\n      onclose: undefined,\n      // Callback function executed when the Gallery has been closed\n      // and the closing transition has been completed.\n      // Is called with the gallery instance as \"this\" object:\n      onclosed: undefined\n    },\n\n    carouselOptions: {\n      hidePageScrollbars: false,\n      toggleControlsOnReturn: false,\n      toggleSlideshowOnSpace: false,\n      enableKeyboardNavigation: false,\n      closeOnEscape: false,\n      closeOnSlideClick: false,\n      closeOnSwipeUpOrDown: false,\n      disableScroll: false,\n      startSlideshow: true\n    },\n\n    console:\n      window.console && typeof window.console.log === 'function'\n        ? window.console\n        : { log: function() {} },\n\n    // Detect touch, transition, transform and background-size support:\n    support: (function(element) {\n      var support = {\n        touch:\n          window.ontouchstart !== undefined ||\n          (window.DocumentTouch && document instanceof DocumentTouch)\n      }\n      var transitions = {\n        webkitTransition: {\n          end: 'webkitTransitionEnd',\n          prefix: '-webkit-'\n        },\n        MozTransition: {\n          end: 'transitionend',\n          prefix: '-moz-'\n        },\n        OTransition: {\n          end: 'otransitionend',\n          prefix: '-o-'\n        },\n        transition: {\n          end: 'transitionend',\n          prefix: ''\n        }\n      }\n      var prop\n      for (prop in transitions) {\n        if (\n          Object.prototype.hasOwnProperty.call(transitions, prop) &&\n          element.style[prop] !== undefined\n        ) {\n          support.transition = transitions[prop]\n          support.transition.name = prop\n          break\n        }\n      }\n      /**\n       * Tests browser support\n       */\n      function elementTests() {\n        var transition = support.transition\n        var prop\n        var translateZ\n        document.body.appendChild(element)\n        if (transition) {\n          prop = transition.name.slice(0, -9) + 'ransform'\n          if (element.style[prop] !== undefined) {\n            element.style[prop] = 'translateZ(0)'\n            translateZ = window\n              .getComputedStyle(element)\n              .getPropertyValue(transition.prefix + 'transform')\n            support.transform = {\n              prefix: transition.prefix,\n              name: prop,\n              translate: true,\n              translateZ: !!translateZ && translateZ !== 'none'\n            }\n          }\n        }\n        if (element.style.backgroundSize !== undefined) {\n          support.backgroundSize = {}\n          element.style.backgroundSize = 'contain'\n          support.backgroundSize.contain =\n            window\n              .getComputedStyle(element)\n              .getPropertyValue('background-size') === 'contain'\n          element.style.backgroundSize = 'cover'\n          support.backgroundSize.cover =\n            window\n              .getComputedStyle(element)\n              .getPropertyValue('background-size') === 'cover'\n        }\n        document.body.removeChild(element)\n      }\n      if (document.body) {\n        elementTests()\n      } else {\n        $(document).on('DOMContentLoaded', elementTests)\n      }\n      return support\n      // Test element, has to be standard HTML and must not be hidden\n      // for the CSS3 tests using window.getComputedStyle to be applicable:\n    })(document.createElement('div')),\n\n    requestAnimationFrame:\n      window.requestAnimationFrame ||\n      window.webkitRequestAnimationFrame ||\n      window.mozRequestAnimationFrame,\n\n    cancelAnimationFrame:\n      window.cancelAnimationFrame ||\n      window.webkitCancelRequestAnimationFrame ||\n      window.webkitCancelAnimationFrame ||\n      window.mozCancelAnimationFrame,\n\n    initialize: function() {\n      this.initStartIndex()\n      if (this.initWidget() === false) {\n        return false\n      }\n      this.initEventListeners()\n      // Load the slide at the given index:\n      this.onslide(this.index)\n      // Manually trigger the slideend event for the initial slide:\n      this.ontransitionend()\n      // Start the automatic slideshow if applicable:\n      if (this.options.startSlideshow) {\n        this.play()\n      }\n    },\n\n    slide: function(to, speed) {\n      window.clearTimeout(this.timeout)\n      var index = this.index\n      var direction\n      var naturalDirection\n      var diff\n      if (index === to || this.num === 1) {\n        return\n      }\n      if (!speed) {\n        speed = this.options.transitionSpeed\n      }\n      if (this.support.transform) {\n        if (!this.options.continuous) {\n          to = this.circle(to)\n        }\n        // 1: backward, -1: forward:\n        direction = Math.abs(index - to) / (index - to)\n        // Get the actual position of the slide:\n        if (this.options.continuous) {\n          naturalDirection = direction\n          direction = -this.positions[this.circle(to)] / this.slideWidth\n          // If going forward but to < index, use to = slides.length + to\n          // If going backward but to > index, use to = -slides.length + to\n          if (direction !== naturalDirection) {\n            to = -direction * this.num + to\n          }\n        }\n        diff = Math.abs(index - to) - 1\n        // Move all the slides between index and to in the right direction:\n        while (diff) {\n          diff -= 1\n          this.move(\n            this.circle((to > index ? to : index) - diff - 1),\n            this.slideWidth * direction,\n            0\n          )\n        }\n        to = this.circle(to)\n        this.move(index, this.slideWidth * direction, speed)\n        this.move(to, 0, speed)\n        if (this.options.continuous) {\n          this.move(\n            this.circle(to - direction),\n            -(this.slideWidth * direction),\n            0\n          )\n        }\n      } else {\n        to = this.circle(to)\n        this.animate(index * -this.slideWidth, to * -this.slideWidth, speed)\n      }\n      this.onslide(to)\n    },\n\n    getIndex: function() {\n      return this.index\n    },\n\n    getNumber: function() {\n      return this.num\n    },\n\n    prev: function() {\n      if (this.options.continuous || this.index) {\n        this.slide(this.index - 1)\n      }\n    },\n\n    next: function() {\n      if (this.options.continuous || this.index < this.num - 1) {\n        this.slide(this.index + 1)\n      }\n    },\n\n    play: function(time) {\n      var that = this\n      window.clearTimeout(this.timeout)\n      this.interval = time || this.options.slideshowInterval\n      if (this.elements[this.index] > 1) {\n        this.timeout = this.setTimeout(\n          (!this.requestAnimationFrame && this.slide) ||\n            function(to, speed) {\n              that.animationFrameId = that.requestAnimationFrame.call(\n                window,\n                function() {\n                  that.slide(to, speed)\n                }\n              )\n            },\n          [this.index + 1, this.options.slideshowTransitionSpeed],\n          this.interval\n        )\n      }\n      this.container.addClass(this.options.playingClass)\n    },\n\n    pause: function() {\n      window.clearTimeout(this.timeout)\n      this.interval = null\n      if (this.cancelAnimationFrame) {\n        this.cancelAnimationFrame.call(window, this.animationFrameId)\n        this.animationFrameId = null\n      }\n      this.container.removeClass(this.options.playingClass)\n    },\n\n    add: function(list) {\n      var i\n      if (!list.concat) {\n        // Make a real array out of the list to add:\n        list = Array.prototype.slice.call(list)\n      }\n      if (!this.list.concat) {\n        // Make a real array out of the Gallery list:\n        this.list = Array.prototype.slice.call(this.list)\n      }\n      this.list = this.list.concat(list)\n      this.num = this.list.length\n      if (this.num > 2 && this.options.continuous === null) {\n        this.options.continuous = true\n        this.container.removeClass(this.options.leftEdgeClass)\n      }\n      this.container\n        .removeClass(this.options.rightEdgeClass)\n        .removeClass(this.options.singleClass)\n      for (i = this.num - list.length; i < this.num; i += 1) {\n        this.addSlide(i)\n        this.positionSlide(i)\n      }\n      this.positions.length = this.num\n      this.initSlides(true)\n    },\n\n    resetSlides: function() {\n      this.slidesContainer.empty()\n      this.unloadAllSlides()\n      this.slides = []\n    },\n\n    handleClose: function() {\n      var options = this.options\n      this.destroyEventListeners()\n      // Cancel the slideshow:\n      this.pause()\n      this.container[0].style.display = 'none'\n      this.container\n        .removeClass(options.displayClass)\n        .removeClass(options.singleClass)\n        .removeClass(options.leftEdgeClass)\n        .removeClass(options.rightEdgeClass)\n      if (options.hidePageScrollbars) {\n        document.body.style.overflow = this.bodyOverflowStyle\n      }\n      if (this.options.clearSlides) {\n        this.resetSlides()\n      }\n      if (this.options.onclosed) {\n        this.options.onclosed.call(this)\n      }\n    },\n\n    close: function() {\n      var that = this\n      /**\n       * Close handler\n       *\n       * @param {event} event Close event\n       */\n      function closeHandler(event) {\n        if (event.target === that.container[0]) {\n          that.container.off(that.support.transition.end, closeHandler)\n          that.handleClose()\n        }\n      }\n      if (this.options.onclose) {\n        this.options.onclose.call(this)\n      }\n      if (this.support.transition && this.options.displayTransition) {\n        this.container.on(this.support.transition.end, closeHandler)\n        this.container.removeClass(this.options.displayClass)\n      } else {\n        this.handleClose()\n      }\n    },\n\n    circle: function(index) {\n      // Always return a number inside of the slides index range:\n      return (this.num + (index % this.num)) % this.num\n    },\n\n    move: function(index, dist, speed) {\n      this.translateX(index, dist, speed)\n      this.positions[index] = dist\n    },\n\n    translate: function(index, x, y, speed) {\n      if (!this.slides[index]) return\n      var style = this.slides[index].style\n      var transition = this.support.transition\n      var transform = this.support.transform\n      style[transition.name + 'Duration'] = speed + 'ms'\n      style[transform.name] =\n        'translate(' +\n        x +\n        'px, ' +\n        y +\n        'px)' +\n        (transform.translateZ ? ' translateZ(0)' : '')\n    },\n\n    translateX: function(index, x, speed) {\n      this.translate(index, x, 0, speed)\n    },\n\n    translateY: function(index, y, speed) {\n      this.translate(index, 0, y, speed)\n    },\n\n    animate: function(from, to, speed) {\n      if (!speed) {\n        this.slidesContainer[0].style.left = to + 'px'\n        return\n      }\n      var that = this\n      var start = new Date().getTime()\n      var timer = window.setInterval(function() {\n        var timeElap = new Date().getTime() - start\n        if (timeElap > speed) {\n          that.slidesContainer[0].style.left = to + 'px'\n          that.ontransitionend()\n          window.clearInterval(timer)\n          return\n        }\n        that.slidesContainer[0].style.left =\n          (to - from) * (Math.floor((timeElap / speed) * 100) / 100) +\n          from +\n          'px'\n      }, 4)\n    },\n\n    preventDefault: function(event) {\n      if (event.preventDefault) {\n        event.preventDefault()\n      } else {\n        event.returnValue = false\n      }\n    },\n\n    stopPropagation: function(event) {\n      if (event.stopPropagation) {\n        event.stopPropagation()\n      } else {\n        event.cancelBubble = true\n      }\n    },\n\n    onresize: function() {\n      this.initSlides(true)\n    },\n\n    onmousedown: function(event) {\n      // Trigger on clicks of the left mouse button only\n      // and exclude video & audio elements:\n      if (\n        event.which &&\n        event.which === 1 &&\n        event.target.nodeName !== 'VIDEO' &&\n        event.target.nodeName !== 'AUDIO'\n      ) {\n        // Preventing the default mousedown action is required\n        // to make touch emulation work with Firefox:\n        event.preventDefault()\n        ;(event.originalEvent || event).touches = [\n          {\n            pageX: event.pageX,\n            pageY: event.pageY\n          }\n        ]\n        this.ontouchstart(event)\n      }\n    },\n\n    onmousemove: function(event) {\n      if (this.touchStart) {\n        ;(event.originalEvent || event).touches = [\n          {\n            pageX: event.pageX,\n            pageY: event.pageY\n          }\n        ]\n        this.ontouchmove(event)\n      }\n    },\n\n    onmouseup: function(event) {\n      if (this.touchStart) {\n        this.ontouchend(event)\n        delete this.touchStart\n      }\n    },\n\n    onmouseout: function(event) {\n      if (this.touchStart) {\n        var target = event.target\n        var related = event.relatedTarget\n        if (!related || (related !== target && !$.contains(target, related))) {\n          this.onmouseup(event)\n        }\n      }\n    },\n\n    ontouchstart: function(event) {\n      if (this.options.stopTouchEventsPropagation) {\n        this.stopPropagation(event)\n      }\n      // jQuery doesn't copy touch event properties by default,\n      // so we have to access the originalEvent object:\n      var touches = (event.originalEvent || event).touches[0]\n      this.touchStart = {\n        // Remember the initial touch coordinates:\n        x: touches.pageX,\n        y: touches.pageY,\n        // Store the time to determine touch duration:\n        time: Date.now()\n      }\n      // Helper variable to detect scroll movement:\n      this.isScrolling = undefined\n      // Reset delta values:\n      this.touchDelta = {}\n    },\n\n    ontouchmove: function(event) {\n      if (this.options.stopTouchEventsPropagation) {\n        this.stopPropagation(event)\n      }\n      // jQuery doesn't copy touch event properties by default,\n      // so we have to access the originalEvent object:\n      var touches = (event.originalEvent || event).touches[0]\n      var scale = (event.originalEvent || event).scale\n      var index = this.index\n      var touchDeltaX\n      var indices\n      // Ensure this is a one touch swipe and not, e.g. a pinch:\n      if (touches.length > 1 || (scale && scale !== 1)) {\n        return\n      }\n      if (this.options.disableScroll) {\n        event.preventDefault()\n      }\n      // Measure change in x and y coordinates:\n      this.touchDelta = {\n        x: touches.pageX - this.touchStart.x,\n        y: touches.pageY - this.touchStart.y\n      }\n      touchDeltaX = this.touchDelta.x\n      // Detect if this is a vertical scroll movement (run only once per touch):\n      if (this.isScrolling === undefined) {\n        this.isScrolling =\n          this.isScrolling ||\n          Math.abs(touchDeltaX) < Math.abs(this.touchDelta.y)\n      }\n      if (!this.isScrolling) {\n        // Always prevent horizontal scroll:\n        event.preventDefault()\n        // Stop the slideshow:\n        window.clearTimeout(this.timeout)\n        if (this.options.continuous) {\n          indices = [this.circle(index + 1), index, this.circle(index - 1)]\n        } else {\n          // Increase resistance if first slide and sliding left\n          // or last slide and sliding right:\n          this.touchDelta.x = touchDeltaX =\n            touchDeltaX /\n            ((!index && touchDeltaX > 0) ||\n            (index === this.num - 1 && touchDeltaX < 0)\n              ? Math.abs(touchDeltaX) / this.slideWidth + 1\n              : 1)\n          indices = [index]\n          if (index) {\n            indices.push(index - 1)\n          }\n          if (index < this.num - 1) {\n            indices.unshift(index + 1)\n          }\n        }\n        while (indices.length) {\n          index = indices.pop()\n          this.translateX(index, touchDeltaX + this.positions[index], 0)\n        }\n      } else {\n        this.translateY(index, this.touchDelta.y + this.positions[index], 0)\n      }\n    },\n\n    ontouchend: function(event) {\n      if (this.options.stopTouchEventsPropagation) {\n        this.stopPropagation(event)\n      }\n      var index = this.index\n      var speed = this.options.transitionSpeed\n      var slideWidth = this.slideWidth\n      var isShortDuration = Number(Date.now() - this.touchStart.time) < 250\n      // Determine if slide attempt triggers next/prev slide:\n      var isValidSlide =\n        (isShortDuration && Math.abs(this.touchDelta.x) > 20) ||\n        Math.abs(this.touchDelta.x) > slideWidth / 2\n      // Determine if slide attempt is past start or end:\n      var isPastBounds =\n        (!index && this.touchDelta.x > 0) ||\n        (index === this.num - 1 && this.touchDelta.x < 0)\n      var isValidClose =\n        !isValidSlide &&\n        this.options.closeOnSwipeUpOrDown &&\n        ((isShortDuration && Math.abs(this.touchDelta.y) > 20) ||\n          Math.abs(this.touchDelta.y) > this.slideHeight / 2)\n      var direction\n      var indexForward\n      var indexBackward\n      var distanceForward\n      var distanceBackward\n      if (this.options.continuous) {\n        isPastBounds = false\n      }\n      // Determine direction of swipe (true: right, false: left):\n      direction = this.touchDelta.x < 0 ? -1 : 1\n      if (!this.isScrolling) {\n        if (isValidSlide && !isPastBounds) {\n          indexForward = index + direction\n          indexBackward = index - direction\n          distanceForward = slideWidth * direction\n          distanceBackward = -slideWidth * direction\n          if (this.options.continuous) {\n            this.move(this.circle(indexForward), distanceForward, 0)\n            this.move(this.circle(index - 2 * direction), distanceBackward, 0)\n          } else if (indexForward >= 0 && indexForward < this.num) {\n            this.move(indexForward, distanceForward, 0)\n          }\n          this.move(index, this.positions[index] + distanceForward, speed)\n          this.move(\n            this.circle(indexBackward),\n            this.positions[this.circle(indexBackward)] + distanceForward,\n            speed\n          )\n          index = this.circle(indexBackward)\n          this.onslide(index)\n        } else {\n          // Move back into position\n          if (this.options.continuous) {\n            this.move(this.circle(index - 1), -slideWidth, speed)\n            this.move(index, 0, speed)\n            this.move(this.circle(index + 1), slideWidth, speed)\n          } else {\n            if (index) {\n              this.move(index - 1, -slideWidth, speed)\n            }\n            this.move(index, 0, speed)\n            if (index < this.num - 1) {\n              this.move(index + 1, slideWidth, speed)\n            }\n          }\n        }\n      } else {\n        if (isValidClose) {\n          this.close()\n        } else {\n          // Move back into position\n          this.translateY(index, 0, speed)\n        }\n      }\n    },\n\n    ontouchcancel: function(event) {\n      if (this.touchStart) {\n        this.ontouchend(event)\n        delete this.touchStart\n      }\n    },\n\n    ontransitionend: function(event) {\n      var slide = this.slides[this.index]\n      if (!event || slide === event.target) {\n        if (this.interval) {\n          this.play()\n        }\n        this.setTimeout(this.options.onslideend, [this.index, slide])\n      }\n    },\n\n    oncomplete: function(event) {\n      var target = event.target || event.srcElement\n      var parent = target && target.parentNode\n      var index\n      if (!target || !parent) {\n        return\n      }\n      index = this.getNodeIndex(parent)\n      $(parent).removeClass(this.options.slideLoadingClass)\n      if (event.type === 'error') {\n        $(parent).addClass(this.options.slideErrorClass)\n        this.elements[index] = 3 // Fail\n      } else {\n        this.elements[index] = 2 // Done\n      }\n      // Fix for IE7's lack of support for percentage max-height:\n      if (target.clientHeight > this.container[0].clientHeight) {\n        target.style.maxHeight = this.container[0].clientHeight\n      }\n      if (this.interval && this.slides[this.index] === parent) {\n        this.play()\n      }\n      this.setTimeout(this.options.onslidecomplete, [index, parent])\n    },\n\n    onload: function(event) {\n      this.oncomplete(event)\n    },\n\n    onerror: function(event) {\n      this.oncomplete(event)\n    },\n\n    onkeydown: function(event) {\n      switch (event.which || event.keyCode) {\n        case 13: // Return\n          if (this.options.toggleControlsOnReturn) {\n            this.preventDefault(event)\n            this.toggleControls()\n          }\n          break\n        case 27: // Esc\n          if (this.options.closeOnEscape) {\n            this.close()\n            // prevent Esc from closing other things\n            event.stopImmediatePropagation()\n          }\n          break\n        case 32: // Space\n          if (this.options.toggleSlideshowOnSpace) {\n            this.preventDefault(event)\n            this.toggleSlideshow()\n          }\n          break\n        case 37: // Left\n          if (this.options.enableKeyboardNavigation) {\n            this.preventDefault(event)\n            this.prev()\n          }\n          break\n        case 39: // Right\n          if (this.options.enableKeyboardNavigation) {\n            this.preventDefault(event)\n            this.next()\n          }\n          break\n      }\n    },\n\n    handleClick: function(event) {\n      var options = this.options\n      var target = event.target || event.srcElement\n      var parent = target.parentNode\n      /**\n       * Checks if the target from the close has the given class\n       *\n       * @param {string} className Class name\n       * @returns {boolean} Returns true if the target has the class name\n       */\n      function isTarget(className) {\n        return $(target).hasClass(className) || $(parent).hasClass(className)\n      }\n      if (isTarget(options.toggleClass)) {\n        // Click on \"toggle\" control\n        this.preventDefault(event)\n        this.toggleControls()\n      } else if (isTarget(options.prevClass)) {\n        // Click on \"prev\" control\n        this.preventDefault(event)\n        this.prev()\n      } else if (isTarget(options.nextClass)) {\n        // Click on \"next\" control\n        this.preventDefault(event)\n        this.next()\n      } else if (isTarget(options.closeClass)) {\n        // Click on \"close\" control\n        this.preventDefault(event)\n        this.close()\n      } else if (isTarget(options.playPauseClass)) {\n        // Click on \"play-pause\" control\n        this.preventDefault(event)\n        this.toggleSlideshow()\n      } else if (parent === this.slidesContainer[0]) {\n        // Click on slide background\n        if (options.closeOnSlideClick) {\n          this.preventDefault(event)\n          this.close()\n        } else if (options.toggleControlsOnSlideClick) {\n          this.preventDefault(event)\n          this.toggleControls()\n        }\n      } else if (\n        parent.parentNode &&\n        parent.parentNode === this.slidesContainer[0]\n      ) {\n        // Click on displayed element\n        if (options.toggleControlsOnSlideClick) {\n          this.preventDefault(event)\n          this.toggleControls()\n        }\n      }\n    },\n\n    onclick: function(event) {\n      if (\n        this.options.emulateTouchEvents &&\n        this.touchDelta &&\n        (Math.abs(this.touchDelta.x) > 20 || Math.abs(this.touchDelta.y) > 20)\n      ) {\n        delete this.touchDelta\n        return\n      }\n      return this.handleClick(event)\n    },\n\n    updateEdgeClasses: function(index) {\n      if (!index) {\n        this.container.addClass(this.options.leftEdgeClass)\n      } else {\n        this.container.removeClass(this.options.leftEdgeClass)\n      }\n      if (index === this.num - 1) {\n        this.container.addClass(this.options.rightEdgeClass)\n      } else {\n        this.container.removeClass(this.options.rightEdgeClass)\n      }\n    },\n\n    handleSlide: function(index) {\n      if (!this.options.continuous) {\n        this.updateEdgeClasses(index)\n      }\n      this.loadElements(index)\n      if (this.options.unloadElements) {\n        this.unloadElements(index)\n      }\n      this.setTitle(index)\n    },\n\n    onslide: function(index) {\n      this.index = index\n      this.handleSlide(index)\n      this.setTimeout(this.options.onslide, [index, this.slides[index]])\n    },\n\n    setTitle: function(index) {\n      var firstChild = this.slides[index].firstChild\n      var text = firstChild.title || firstChild.alt\n      var titleElement = this.titleElement\n      if (titleElement.length) {\n        this.titleElement.empty()\n        if (text) {\n          titleElement[0].appendChild(document.createTextNode(text))\n        }\n      }\n    },\n\n    setTimeout: function(func, args, wait) {\n      var that = this\n      return (\n        func &&\n        window.setTimeout(function() {\n          func.apply(that, args || [])\n        }, wait || 0)\n      )\n    },\n\n    imageFactory: function(obj, callback) {\n      var that = this\n      var img = this.imagePrototype.cloneNode(false)\n      var url = obj\n      var backgroundSize = this.options.stretchImages\n      var called\n      var element\n      var title\n      var altText\n      /**\n       * Wraps the callback function for the load/error event\n       *\n       * @param {event} event load/error event\n       * @returns {number} timeout ID\n       */\n      function callbackWrapper(event) {\n        if (!called) {\n          event = {\n            type: event.type,\n            target: element\n          }\n          if (!element.parentNode) {\n            // Fix for IE7 firing the load event for\n            // cached images before the element could\n            // be added to the DOM:\n            return that.setTimeout(callbackWrapper, [event])\n          }\n          called = true\n          $(img).off('load error', callbackWrapper)\n          if (backgroundSize) {\n            if (event.type === 'load') {\n              element.style.background = 'url(\"' + url + '\") center no-repeat'\n              element.style.backgroundSize = backgroundSize\n            }\n          }\n          callback(event)\n        }\n      }\n      if (typeof url !== 'string') {\n        url = this.getItemProperty(obj, this.options.urlProperty)\n        title = this.getItemProperty(obj, this.options.titleProperty)\n        altText =\n          this.getItemProperty(obj, this.options.altTextProperty) || title\n      }\n      if (backgroundSize === true) {\n        backgroundSize = 'contain'\n      }\n      backgroundSize =\n        this.support.backgroundSize &&\n        this.support.backgroundSize[backgroundSize] &&\n        backgroundSize\n      if (backgroundSize) {\n        element = this.elementPrototype.cloneNode(false)\n      } else {\n        element = img\n        img.draggable = false\n      }\n      if (title) {\n        element.title = title\n      }\n      if (altText) {\n        element.alt = altText\n      }\n      $(img).on('load error', callbackWrapper)\n      img.src = url\n      return element\n    },\n\n    createElement: function(obj, callback) {\n      var type = obj && this.getItemProperty(obj, this.options.typeProperty)\n      var factory =\n        (type && this[type.split('/')[0] + 'Factory']) || this.imageFactory\n      var element = obj && factory.call(this, obj, callback)\n      var srcset = this.getItemProperty(obj, this.options.srcsetProperty)\n      if (!element) {\n        element = this.elementPrototype.cloneNode(false)\n        this.setTimeout(callback, [\n          {\n            type: 'error',\n            target: element\n          }\n        ])\n      }\n      if (srcset) {\n        element.setAttribute('srcset', srcset)\n      }\n      $(element).addClass(this.options.slideContentClass)\n      return element\n    },\n\n    loadElement: function(index) {\n      if (!this.elements[index]) {\n        if (this.slides[index].firstChild) {\n          this.elements[index] = $(this.slides[index]).hasClass(\n            this.options.slideErrorClass\n          )\n            ? 3\n            : 2\n        } else {\n          this.elements[index] = 1 // Loading\n          $(this.slides[index]).addClass(this.options.slideLoadingClass)\n          this.slides[index].appendChild(\n            this.createElement(this.list[index], this.proxyListener)\n          )\n        }\n      }\n    },\n\n    loadElements: function(index) {\n      var limit = Math.min(this.num, this.options.preloadRange * 2 + 1)\n      var j = index\n      var i\n      for (i = 0; i < limit; i += 1) {\n        // First load the current slide element (0),\n        // then the next one (+1),\n        // then the previous one (-2),\n        // then the next after next (+2), etc.:\n        j += i * (i % 2 === 0 ? -1 : 1)\n        // Connect the ends of the list to load slide elements for\n        // continuous navigation:\n        j = this.circle(j)\n        this.loadElement(j)\n      }\n    },\n\n    unloadElements: function(index) {\n      var i, diff\n      for (i in this.elements) {\n        if (Object.prototype.hasOwnProperty.call(this.elements, i)) {\n          diff = Math.abs(index - i)\n          if (\n            diff > this.options.preloadRange &&\n            diff + this.options.preloadRange < this.num\n          ) {\n            this.unloadSlide(i)\n            delete this.elements[i]\n          }\n        }\n      }\n    },\n\n    addSlide: function(index) {\n      var slide = this.slidePrototype.cloneNode(false)\n      slide.setAttribute('data-index', index)\n      this.slidesContainer[0].appendChild(slide)\n      this.slides.push(slide)\n    },\n\n    positionSlide: function(index) {\n      var slide = this.slides[index]\n      slide.style.width = this.slideWidth + 'px'\n      if (this.support.transform) {\n        slide.style.left = index * -this.slideWidth + 'px'\n        this.move(\n          index,\n          this.index > index\n            ? -this.slideWidth\n            : this.index < index\n            ? this.slideWidth\n            : 0,\n          0\n        )\n      }\n    },\n\n    initSlides: function(reload) {\n      var clearSlides, i\n      if (!reload) {\n        this.positions = []\n        this.positions.length = this.num\n        this.elements = {}\n        this.imagePrototype = document.createElement('img')\n        this.elementPrototype = document.createElement('div')\n        this.slidePrototype = document.createElement('div')\n        $(this.slidePrototype).addClass(this.options.slideClass)\n        this.slides = this.slidesContainer[0].children\n        clearSlides =\n          this.options.clearSlides || this.slides.length !== this.num\n      }\n      this.slideWidth = this.container[0].clientWidth\n      this.slideHeight = this.container[0].clientHeight\n      this.slidesContainer[0].style.width = this.num * this.slideWidth + 'px'\n      if (clearSlides) {\n        this.resetSlides()\n      }\n      for (i = 0; i < this.num; i += 1) {\n        if (clearSlides) {\n          this.addSlide(i)\n        }\n        this.positionSlide(i)\n      }\n      // Reposition the slides before and after the given index:\n      if (this.options.continuous && this.support.transform) {\n        this.move(this.circle(this.index - 1), -this.slideWidth, 0)\n        this.move(this.circle(this.index + 1), this.slideWidth, 0)\n      }\n      if (!this.support.transform) {\n        this.slidesContainer[0].style.left =\n          this.index * -this.slideWidth + 'px'\n      }\n    },\n\n    unloadSlide: function(index) {\n      var slide, firstChild\n      slide = this.slides[index]\n      firstChild = slide.firstChild\n      if (firstChild !== null) {\n        slide.removeChild(firstChild)\n      }\n    },\n\n    unloadAllSlides: function() {\n      var i, len\n      for (i = 0, len = this.slides.length; i < len; i++) {\n        this.unloadSlide(i)\n      }\n    },\n\n    toggleControls: function() {\n      var controlsClass = this.options.controlsClass\n      if (this.container.hasClass(controlsClass)) {\n        this.container.removeClass(controlsClass)\n      } else {\n        this.container.addClass(controlsClass)\n      }\n    },\n\n    toggleSlideshow: function() {\n      if (!this.interval) {\n        this.play()\n      } else {\n        this.pause()\n      }\n    },\n\n    getNodeIndex: function(element) {\n      return parseInt(element.getAttribute('data-index'), 10)\n    },\n\n    getNestedProperty: function(obj, property) {\n      property.replace(\n        // Matches native JavaScript notation in a String,\n        // e.g. '[\"doubleQuoteProp\"].dotProp[2]'\n        // eslint-disable-next-line no-useless-escape\n        /\\[(?:'([^']+)'|\"([^\"]+)\"|(\\d+))\\]|(?:(?:^|\\.)([^\\.\\[]+))/g,\n        function(str, singleQuoteProp, doubleQuoteProp, arrayIndex, dotProp) {\n          var prop =\n            dotProp ||\n            singleQuoteProp ||\n            doubleQuoteProp ||\n            (arrayIndex && parseInt(arrayIndex, 10))\n          if (str && obj) {\n            obj = obj[prop]\n          }\n        }\n      )\n      return obj\n    },\n\n    getDataProperty: function(obj, property) {\n      var key\n      var prop\n      if (obj.dataset) {\n        key = property.replace(/-([a-z])/g, function(_, b) {\n          return b.toUpperCase()\n        })\n        prop = obj.dataset[key]\n      } else if (obj.getAttribute) {\n        prop = obj.getAttribute(\n          'data-' + property.replace(/([A-Z])/g, '-$1').toLowerCase()\n        )\n      }\n      if (typeof prop === 'string') {\n        // eslint-disable-next-line no-useless-escape\n        if (\n          /^(true|false|null|-?\\d+(\\.\\d+)?|\\{[\\s\\S]*\\}|\\[[\\s\\S]*\\])$/.test(prop)\n        ) {\n          try {\n            return $.parseJSON(prop)\n          } catch (ignore) {\n            // ignore JSON parsing errors\n          }\n        }\n        return prop\n      }\n    },\n\n    getItemProperty: function(obj, property) {\n      var prop = this.getDataProperty(obj, property)\n      if (prop === undefined) {\n        prop = obj[property]\n      }\n      if (prop === undefined) {\n        prop = this.getNestedProperty(obj, property)\n      }\n      return prop\n    },\n\n    initStartIndex: function() {\n      var index = this.options.index\n      var urlProperty = this.options.urlProperty\n      var i\n      // Check if the index is given as a list object:\n      if (index && typeof index !== 'number') {\n        for (i = 0; i < this.num; i += 1) {\n          if (\n            this.list[i] === index ||\n            this.getItemProperty(this.list[i], urlProperty) ===\n              this.getItemProperty(index, urlProperty)\n          ) {\n            index = i\n            break\n          }\n        }\n      }\n      // Make sure the index is in the list range:\n      this.index = this.circle(parseInt(index, 10) || 0)\n    },\n\n    initEventListeners: function() {\n      var that = this\n      var slidesContainer = this.slidesContainer\n      /**\n       * Proxy listener\n       *\n       * @param {event} event original event\n       */\n      function proxyListener(event) {\n        var type =\n          that.support.transition && that.support.transition.end === event.type\n            ? 'transitionend'\n            : event.type\n        that['on' + type](event)\n      }\n      $(window).on('resize', proxyListener)\n      $(document.body).on('keydown', proxyListener)\n      this.container.on('click', proxyListener)\n      if (this.support.touch) {\n        slidesContainer.on(\n          'touchstart touchmove touchend touchcancel',\n          proxyListener\n        )\n      } else if (this.options.emulateTouchEvents && this.support.transition) {\n        slidesContainer.on(\n          'mousedown mousemove mouseup mouseout',\n          proxyListener\n        )\n      }\n      if (this.support.transition) {\n        slidesContainer.on(this.support.transition.end, proxyListener)\n      }\n      this.proxyListener = proxyListener\n    },\n\n    destroyEventListeners: function() {\n      var slidesContainer = this.slidesContainer\n      var proxyListener = this.proxyListener\n      $(window).off('resize', proxyListener)\n      $(document.body).off('keydown', proxyListener)\n      this.container.off('click', proxyListener)\n      if (this.support.touch) {\n        slidesContainer.off(\n          'touchstart touchmove touchend touchcancel',\n          proxyListener\n        )\n      } else if (this.options.emulateTouchEvents && this.support.transition) {\n        slidesContainer.off(\n          'mousedown mousemove mouseup mouseout',\n          proxyListener\n        )\n      }\n      if (this.support.transition) {\n        slidesContainer.off(this.support.transition.end, proxyListener)\n      }\n    },\n\n    handleOpen: function() {\n      if (this.options.onopened) {\n        this.options.onopened.call(this)\n      }\n    },\n\n    initWidget: function() {\n      var that = this\n      /**\n       * Open handler\n       *\n       * @param {event} event Gallery open event\n       */\n      function openHandler(event) {\n        if (event.target === that.container[0]) {\n          that.container.off(that.support.transition.end, openHandler)\n          that.handleOpen()\n        }\n      }\n      this.container = $(this.options.container)\n      if (!this.container.length) {\n        this.console.log(\n          'blueimp Gallery: Widget container not found.',\n          this.options.container\n        )\n        return false\n      }\n      this.slidesContainer = this.container\n        .find(this.options.slidesContainer)\n        .first()\n      if (!this.slidesContainer.length) {\n        this.console.log(\n          'blueimp Gallery: Slides container not found.',\n          this.options.slidesContainer\n        )\n        return false\n      }\n      this.titleElement = this.container.find(this.options.titleElement).first()\n      if (this.num === 1) {\n        this.container.addClass(this.options.singleClass)\n      }\n      if (this.options.onopen) {\n        this.options.onopen.call(this)\n      }\n      if (this.support.transition && this.options.displayTransition) {\n        this.container.on(this.support.transition.end, openHandler)\n      } else {\n        this.handleOpen()\n      }\n      if (this.options.hidePageScrollbars) {\n        // Hide the page scrollbars:\n        this.bodyOverflowStyle = document.body.style.overflow\n        document.body.style.overflow = 'hidden'\n      }\n      this.container[0].style.display = 'block'\n      this.initSlides()\n      this.container.addClass(this.options.displayClass)\n    },\n\n    initOptions: function(options) {\n      // Create a copy of the prototype options:\n      this.options = $.extend({}, this.options)\n      // Check if carousel mode is enabled:\n      if (\n        (options && options.carousel) ||\n        (this.options.carousel && (!options || options.carousel !== false))\n      ) {\n        $.extend(this.options, this.carouselOptions)\n      }\n      // Override any given options:\n      $.extend(this.options, options)\n      if (this.num < 3) {\n        // 1 or 2 slides cannot be displayed continuous,\n        // remember the original option by setting to null instead of false:\n        this.options.continuous = this.options.continuous ? null : false\n      }\n      if (!this.support.transition) {\n        this.options.emulateTouchEvents = false\n      }\n      if (this.options.event) {\n        this.preventDefault(this.options.event)\n      }\n    }\n  })\n\n  return Gallery\n})\n","/*\n * blueimp helper JS\n * https://github.com/blueimp/Gallery\n *\n * Copyright 2013, Sebastian Tschan\n * https://blueimp.net\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n */\n\n/* global define */\n\n/* eslint-disable no-param-reassign */\n\n;(function() {\n  'use strict'\n\n  /**\n   * Object.assign polyfill\n   *\n   * @param {object} obj1 First object\n   * @param {object} obj2 Second object\n   * @returns {object} Merged object\n   */\n  function extend(obj1, obj2) {\n    var prop\n    for (prop in obj2) {\n      if (Object.prototype.hasOwnProperty.call(obj2, prop)) {\n        obj1[prop] = obj2[prop]\n      }\n    }\n    return obj1\n  }\n  /**\n   * Helper constructor\n   *\n   * @class\n   * @param {*} query jQuery type query argument\n   */\n  function Helper(query) {\n    if (!this || this.find !== Helper.prototype.find) {\n      // Called as function instead of as constructor,\n      // so we simply return a new instance:\n      return new Helper(query)\n    }\n    this.length = 0\n    if (query) {\n      if (typeof query === 'string') {\n        query = this.find(query)\n      }\n      if (query.nodeType || query === query.window) {\n        // Single HTML element\n        this.length = 1\n        this[0] = query\n      } else {\n        // HTML element collection\n        var i = query.length\n        this.length = i\n        while (i) {\n          i -= 1\n          this[i] = query[i]\n        }\n      }\n    }\n  }\n\n  Helper.extend = extend\n\n  Helper.contains = function(container, element) {\n    do {\n      element = element.parentNode\n      if (element === container) {\n        return true\n      }\n    } while (element)\n    return false\n  }\n\n  Helper.parseJSON = function(string) {\n    return window.JSON && JSON.parse(string)\n  }\n\n  extend(Helper.prototype, {\n    find: function(query) {\n      var container = this[0] || document\n      if (typeof query === 'string') {\n        if (container.querySelectorAll) {\n          query = container.querySelectorAll(query)\n        } else if (query.charAt(0) === '#') {\n          query = container.getElementById(query.slice(1))\n        } else {\n          query = container.getElementsByTagName(query)\n        }\n      }\n      return new Helper(query)\n    },\n\n    hasClass: function(className) {\n      if (!this[0]) {\n        return false\n      }\n      return new RegExp('(^|\\\\s+)' + className + '(\\\\s+|$)').test(\n        this[0].className\n      )\n    },\n\n    addClass: function(className) {\n      var i = this.length\n      var element\n      while (i) {\n        i -= 1\n        element = this[i]\n        if (!element.className) {\n          element.className = className\n          return this\n        }\n        if (this.hasClass(className)) {\n          return this\n        }\n        element.className += ' ' + className\n      }\n      return this\n    },\n\n    removeClass: function(className) {\n      var regexp = new RegExp('(^|\\\\s+)' + className + '(\\\\s+|$)')\n      var i = this.length\n      var element\n      while (i) {\n        i -= 1\n        element = this[i]\n        element.className = element.className.replace(regexp, ' ')\n      }\n      return this\n    },\n\n    on: function(eventName, handler) {\n      var eventNames = eventName.split(/\\s+/)\n      var i\n      var element\n      while (eventNames.length) {\n        eventName = eventNames.shift()\n        i = this.length\n        while (i) {\n          i -= 1\n          element = this[i]\n          if (element.addEventListener) {\n            element.addEventListener(eventName, handler, false)\n          } else if (element.attachEvent) {\n            element.attachEvent('on' + eventName, handler)\n          }\n        }\n      }\n      return this\n    },\n\n    off: function(eventName, handler) {\n      var eventNames = eventName.split(/\\s+/)\n      var i\n      var element\n      while (eventNames.length) {\n        eventName = eventNames.shift()\n        i = this.length\n        while (i) {\n          i -= 1\n          element = this[i]\n          if (element.removeEventListener) {\n            element.removeEventListener(eventName, handler, false)\n          } else if (element.detachEvent) {\n            element.detachEvent('on' + eventName, handler)\n          }\n        }\n      }\n      return this\n    },\n\n    empty: function() {\n      var i = this.length\n      var element\n      while (i) {\n        i -= 1\n        element = this[i]\n        while (element.hasChildNodes()) {\n          element.removeChild(element.lastChild)\n        }\n      }\n      return this\n    },\n\n    first: function() {\n      return new Helper(this[0])\n    }\n  })\n\n  if (typeof define === 'function' && define.amd) {\n    define(function() {\n      return Helper\n    })\n  } else {\n    window.blueimp = window.blueimp || {}\n    window.blueimp.helper = Helper\n  }\n})()\n","/**\n* @preserve ScrollStory - vVERSIONXXX - YYYY-MM-DDXXX\n* https://github.com/sjwilliams/scrollstory\n* Copyright (c) 2017 Josh Williams; Licensed MIT \n*/\n\n(function(factory) {\n  if (typeof define === 'function' && define.amd) {\n    define(['jquery'], factory);\n  } else {\n    factory(jQuery);\n  }\n}(function($, undefined) {\n\n  var pluginName = 'scrollStory';\n  var eventNameSpace = '.' + pluginName;\n  var defaults = {\n\n    // jquery object, class selector string, or array of values, or null (to use existing DOM)\n    content: null,\n\n    // Only used if content null. Should be a class selector\n    contentSelector: '.story',\n\n    // Left/right keys to navigate\n    keyboard: true,\n\n    // Offset from top used in the programatic scrolling of an\n    // item to the focus position. Useful in the case of thinks like\n    // top nav that might obscure part of an item if it goes to 0.\n    scrollOffset: 0,\n\n    // Offset from top to trigger a change\n    triggerOffset: 0,\n\n    // Event to monitor. Can be a name for an event on the $(window), or\n    // a function that defines custom behavior. Defaults to native scroll event.\n    scrollEvent: 'scroll',\n\n    // Automatically activate the first item on load, \n    // regardless of its position relative to the offset\n    autoActivateFirstItem: false,\n\n    // Disable last item -- and the entire widget -- once it's scroll beyond the trigger point\n    disablePastLastItem: true,\n\n    // Automated scroll speed in ms. Set to 0 to remove animation.\n    speed: 800,\n\n    // Scroll easing. 'swing' or 'linear', unless an external plugin provides others\n    // http://api.jquery.com/animate/\n    easing: 'swing',\n\n    // // scroll-based events are either 'debounce' or 'throttle'\n    throttleType: 'throttle',\n\n    // frequency in milliseconds to perform scroll-based functions. Scrolling functions \n    // can be CPU intense, so higher number can help performance.\n    scrollSensitivity: 100,\n\n    // options to pass to underscore's throttle or debounce for scroll\n    // see: http://underscorejs.org/#throttle && http://underscorejs.org/#debounce\n    throttleTypeOptions: null,\n\n    // Update offsets after likely repaints, like window resizes and filters\n    autoUpdateOffsets: true,\n\n    debug: false,\n\n    // whether or not the scroll checking is enabled.\n    enabled: true,\n\n    setup: $.noop,\n    destroy: $.noop,\n    itembuild: $.noop,\n    itemfocus: $.noop,\n    itemblur: $.noop,\n    itemfilter: $.noop,\n    itemunfilter: $.noop,\n    itementerviewport: $.noop,\n    itemexitviewport: $.noop,\n    categoryfocus: $.noop,\n    categeryblur: $.noop,\n    containeractive: $.noop,\n    containerinactive: $.noop,\n    containerresize: $.noop,\n    containerscroll: $.noop,\n    updateoffsets: $.noop,\n    triggeroffsetupdate: $.noop,\n    scrolloffsetupdate: $.noop,\n    complete: $.noop\n  };\n\n  // static across all plugin instances\n  // so we can uniquely ID elements\n  var instanceCounter = 0;\n\n\n\n\n  /**\n   * Utility methods\n   *\n   * debounce() and throttle() are from on Underscore.js:\n   * https://github.com/jashkenas/underscore\n   */\n\n  /**\n   * Underscore's now:\n   * http://underscorejs.org/now\n   */\n  var dateNow = Date.now || function() {\n    return new Date().getTime();\n  };\n\n  /**\n   * Underscore's debounce:\n   * http://underscorejs.org/#debounce\n   */\n  var debounce = function(func, wait, immediate) {\n    var result;\n    var timeout = null;\n    return function() {\n      var context = this,\n        args = arguments;\n      var later = function() {\n        timeout = null;\n        if (!immediate) {\n          result = func.apply(context, args);\n        }\n      };\n      var callNow = immediate && !timeout;\n      clearTimeout(timeout);\n      timeout = setTimeout(later, wait);\n      if (callNow) {\n        result = func.apply(context, args);\n      }\n      return result;\n    };\n  };\n\n  /**\n   * Underscore's throttle:\n   * http://underscorejs.org/#throttle\n   */\n  var throttle = function(func, wait, options) {\n    var context, args, result;\n    var timeout = null;\n    var previous = 0;\n    options || (options = {});\n    var later = function() {\n      previous = options.leading === false ? 0 : dateNow();\n      timeout = null;\n      result = func.apply(context, args);\n    };\n    return function() {\n      var now = dateNow();\n      if (!previous && options.leading === false) {\n        previous = now;\n      }\n      var remaining = wait - (now - previous);\n      context = this;\n      args = arguments;\n      if (remaining <= 0) {\n        clearTimeout(timeout);\n        timeout = null;\n        previous = now;\n        result = func.apply(context, args);\n      } else if (!timeout && options.trailing !== false) {\n        timeout = setTimeout(later, remaining);\n      }\n      return result;\n    };\n  };\n\n  var $window = $(window);\n  var winHeight = $window.height(); // cached. updated via _handleResize()\n\n  /**\n   * Given a scroll/trigger offset, determine\n   * its pixel value from the top of the viewport. \n   * \n   * If number or number-like string (30 or '30'), return that \n   * number. (30)\n   *\n   * If it's a percentage string ('30%'), convert to pixels\n   * based on the height of the viewport. (eg: 395) \n   * \n   * @param  {String/Number} offset\n   * @return {Number}\n   */\n  var offsetToPx = function(offset){\n    var pxOffset;\n\n    if (offsetIsAPercentage(offset)) {\n      pxOffset = offset.slice(0, -1);\n      pxOffset = Math.round(winHeight * (parseInt(pxOffset, 10)/100) );\n    } else {\n      pxOffset = parseInt(offset, 10);\n    }\n\n    return pxOffset;\n  };\n\n  var offsetIsAPercentage = function(offset){\n    return typeof offset === 'string' && offset.slice(-1) === '%';\n  };\n\n\n  function ScrollStory(element, options) {\n    this.el = element;\n    this.$el = $(element);\n    this.options = $.extend({}, defaults, options);\n\n    this.useNativeScroll = (typeof this.options.scrollEvent === 'string') && (this.options.scrollEvent.indexOf('scroll') === 0);\n\n    this._defaults = defaults;\n    this._name = pluginName;\n    this._instanceId = (function() {\n      return pluginName + '_' + instanceCounter;\n    })();\n    \n    this.init();\n  }\n\n  ScrollStory.prototype = {\n    init: function() {\n      \n      /**\n       * List of all items, and a quick lockup hash\n       * Data populated via _prepItems* methods\n       */\n      this._items = [];\n      this._itemsById = {};\n      this._categories = [];\n      this._tags = [];\n\n      this._isActive = false;\n      this._activeItem;\n      this._previousItems = [];\n\n      /**\n       * Attach handlers before any events are dispatched\n       */\n      this.$el.on('setup'+eventNameSpace, this._onSetup.bind(this));\n      this.$el.on('destroy'+eventNameSpace, this._onDestroy.bind(this));\n      this.$el.on('containeractive'+eventNameSpace, this._onContainerActive.bind(this));\n      this.$el.on('containerinactive'+eventNameSpace, this._onContainerInactive.bind(this));\n      this.$el.on('itemblur'+eventNameSpace, this._onItemBlur.bind(this));\n      this.$el.on('itemfocus'+eventNameSpace, this._onItemFocus.bind(this));\n      this.$el.on('itementerviewport'+eventNameSpace, this._onItemEnterViewport.bind(this));\n      this.$el.on('itemexitviewport'+eventNameSpace, this._onItemExitViewport.bind(this));\n      this.$el.on('itemfilter'+eventNameSpace, this._onItemFilter.bind(this));\n      this.$el.on('itemunfilter'+eventNameSpace, this._onItemUnfilter.bind(this));\n      this.$el.on('categoryfocus'+eventNameSpace, this._onCategoryFocus.bind(this));\n      this.$el.on('triggeroffsetupdate'+eventNameSpace, this._onTriggerOffsetUpdate.bind(this));\n\n\n      /**\n       * Run before any items have been added, allows\n       * for user manipulation of page before ScrollStory\n       * acts on anything.\n       */\n      this._trigger('setup', null, this);\n\n\n      /**\n       * Convert data from outside of widget into\n       * items and, if needed, categories of items.\n       *\n       * Don't 'handleRepaints' just yet, as that'll\n       * set an active item. We want to do that after\n       * our 'complete' event is triggered.\n       */\n      this.addItems(this.options.content, {\n        handleRepaint: false\n      });\n\n      // 1. offsets need to be accurate before 'complete'\n      this.updateOffsets();\n\n      // 2. handle any user actions\n      this._trigger('complete', null, this);\n\n      // 3. Set active item, and double check \n      // scroll position and offsets.\n      if(this.options.enabled){\n        this._handleRepaint();\n      }\n\n\n      /**\n       * Bind keyboard events\n       */\n      if (this.options.keyboard) {\n        $(document).keydown(function(e){\n          var captured = true;\n          switch (e.keyCode) {\n            case 37:\n              if (e.metaKey) {return;} // ignore ctrl/cmd left, as browsers use that to go back in history\n              this.previous();\n              break; // left arrow\n            case 39:\n              this.next();\n              break; // right arrow\n            default:\n              captured = false;\n          }\n          return !captured;\n        }.bind(this));\n      }\n\n\n\n      /**\n       * Debug UI\n       */\n      this.$trigger = $('<div class=\"' + pluginName + 'Trigger\"></div>').css({\n        position: 'fixed',\n        width: '100%',\n        height: '1px',\n        top: offsetToPx(this.options.triggerOffset) + 'px',\n        left: '0px',\n        backgroundColor: '#ff0000',\n        '-webkit-transform': 'translateZ(0)',\n        '-webkit-backface-visibility': 'hidden',\n        zIndex: 1000\n      }).attr('id', pluginName + 'Trigger-' + this._instanceId);\n      \n      if (this.options.debug) {\n        this.$trigger.appendTo('body');\n      }\n\n\n      /**\n       * Watch either native scroll events, throttled by \n       * this.options.scrollSensitivity, or a custom event \n       * that implements its own throttling.\n       *\n       * Bind these events after 'complete' trigger so no\n       * items are active when those callbacks runs.\n       */\n      \n      var scrollThrottle, scrollHandler;\n\n      if(this.useNativeScroll){\n\n        // bind and throttle native scroll\n        scrollThrottle = (this.options.throttleType === 'throttle') ? throttle : debounce;\n        scrollHandler = scrollThrottle(this._handleScroll.bind(this), this.options.scrollSensitivity, this.options.throttleTypeOptions);\n        $window.on('scroll'+eventNameSpace, scrollHandler);\n      } else {\n\n        // bind but don't throttle custom event\n        scrollHandler = this._handleScroll.bind(this);\n\n        // if custom event is a function, it'll need\n        // to call the scroll handler manually, like so:\n        //\n        //  $container.scrollStory({\n        //    scrollEvent: function(cb){\n        //      // custom scroll event on nytimes.com\n        //      PageManager.on('nyt:page-scroll', function(){\n        //       // do something interesting if you like\n        //       // and then call the passed in handler();\n        //       cb();\n        //     });\n        //    }\n        //  });\n        //\n        //\n        // Otherwise, it's a string representing an event on the\n        // window to subscribe to, like so:\n        //\n        // // some code dispatching throttled events\n        // $window.trigger('nytg-scroll');\n        // \n        //  $container.scrollStory({\n        //    scrollEvent: 'nytg-scroll'\n        //  });\n        //\n\n        if (typeof this.options.scrollEvent === 'function') {\n          this.options.scrollEvent(scrollHandler);\n        } else {\n          $window.on(this.options.scrollEvent+eventNameSpace, function(){\n            scrollHandler();\n          });\n        }\n      }\n\n      // anything that might cause a repaint      \n      var resizeThrottle = debounce(this._handleResize, 100);\n      $window.on('DOMContentLoaded'+eventNameSpace + ' load'+eventNameSpace + ' resize'+eventNameSpace, resizeThrottle.bind(this));\n\n      instanceCounter = instanceCounter + 1;\n    },\n\n\n    /**\n     * Get current item's index, \n     * or set the current item with an index.\n     * @param  {Number} index\n     * @param  {Function} callback\n     * @return {Number} index of active item\n     */\n    index: function(index, callback) {\n      if (typeof index === 'number' && this.getItemByIndex(index)) {\n        this.setActiveItem(this.getItemByIndex(index), {}, callback);\n      } else {\n        return this.getActiveItem().index;\n      }\n    },\n\n\n    /**\n     * Convenience method to navigate to next item\n     *\n     * @param  {Number} _index -- an optional index. Used to recursively find unflitered item \n     */\n    next: function(_index) {\n      var currentIndex = _index || this.index();\n      var nextItem;\n\n      if (typeof currentIndex === 'number') {\n        nextItem = this.getItemByIndex(currentIndex + 1);\n\n        // valid index and item\n        if (nextItem) {\n\n          // proceed if not filtered. if filtered try the one after that.\n          if (!nextItem.filtered) {\n            this.index(currentIndex + 1);\n          } else {\n            this.next(currentIndex + 1);\n          }\n        }\n      }\n    },\n\n\n    /**\n     * Convenience method to navigate to previous item\n     *\n     * @param  {Number} _index -- an optional index. Used to recursively find unflitered item \n     */\n    previous: function(_index) {\n      var currentIndex = _index || this.index();\n      var previousItem;\n\n      if (typeof currentIndex === 'number') {\n        previousItem = this.getItemByIndex(currentIndex - 1);\n\n        // valid index and item\n        if (previousItem) {\n\n          // proceed if not filtered. if filtered try the one before that.\n          if (!previousItem.filtered) {\n            this.index(currentIndex - 1);            \n          } else {\n            this.previous(currentIndex - 1);\n          }\n        }\n      }\n    },\n\n\n    /**\n     * The active item object.\n     * \n     * @return {Object}\n     */\n    getActiveItem: function() {\n      return this._activeItem;\n    },\n\n\n    /**\n     * Given an item object, make it active,\n     * including updating its scroll position. \n     * \n     * @param {Object} item\n     */\n    setActiveItem: function(item, options, callback) {\n      options = options || {};\n\n      // verify item\n      if (item.id && this.getItemById(item.id)) {\n        this._scrollToItem(item, options, callback);\n      }\n    },\n\n\n    /**\n     * Iterate over each item, passing the item to a callback.\n     *\n     * this.each(function(item){ console.log(item.id) });\n     *\n     * @param {Function}\n     */\n    each: function(callback) {\n      this.applyToAllItems(callback);\n    },\n\n\n    /**\n     * Return number of items\n     * @return {Number}\n     */\n    getLength: function() {\n      return this.getItems().length;\n    },\n\n    /**\n     * Return array of all items\n     * @return {Array}\n     */\n    getItems: function() {\n      return this._items;\n    },\n\n\n    /**\n     * Given an item id, return item object with that id.\n     *\n     * @param  {string} id\n     * @return {Object}\n     */\n    getItemById: function(id) {\n      return this._itemsById[id];\n    },\n\n\n    /**\n     * Given an item index, return item object with that index.\n     *\n     * @param  {Integer} index\n     * @return {Object}\n     */\n    getItemByIndex: function(index) {\n      return this._items[index];\n    },\n\n\n    /**\n     * Return an array of items that pass an abritrary truth test.\n     *\n     * Example: this.getItemsBy(function(item){return item.data.slug=='josh_williams'})\n     *\n     * @param {Function} truthTest The function to check all items against\n     * @return {Array} Array of item objects\n     */\n    getItemsBy: function(truthTest) {\n      if (typeof truthTest !== 'function') {\n        throw new Error('You must provide a truthTest function');\n      }\n\n      return this.getItems().filter(function(item) {\n        return truthTest(item);\n      });\n    },\n\n\n    /**\n     * Returns an array of items where all the properties\n     * match an item's properties. Property tests can be\n     * any combination of:\n     *\n     * 1. Values\n     * this.getItemsWhere({index:2});\n     * this.getItemsWhere({filtered:false});\n     * this.getItemsWhere({category:'cats', width: 300});\n     *\n     * 2. Methods that return a value\n     * this.getItemsWhere({width: function(width){ return 216 + 300;}});\n     *\n     * 3. Methods that return a boolean\n     * this.getItemsWhere({index: function(index){ return index > 2; } });\n     *\n     * Mix and match:\n     * this.getItemsWehre({filtered:false, index: function(index){ return index < 30;} })\n     *\n     * @param  {Object} properties\n     * @return {Array} Array of item objects\n     */\n    getItemsWhere: function(properties) {\n      var keys,\n        items = []; // empty if properties obj not passed in\n\n      if ($.isPlainObject(properties)) {\n        keys = Object.keys(properties); // properties to check in each item\n        items = this.getItemsBy(function(item) {\n          var isMatch = keys.every(function(key) {\n            var match;\n\n            // type 3, method that runs a boolean\n            if (typeof properties[key] === 'function') {\n              match = properties[key](item[key]);\n\n              // type 2, method that runs a value\n              if (typeof match !== 'boolean') {\n                match = item[key] === match;\n              }\n\n            } else {\n              \n              // type 1, value\n              match = item[key] === properties[key];\n            }\n            return match;\n          });\n\n          if (isMatch) {\n            return item;\n          }\n        });\n      }\n\n      return items;\n    },\n\n\n    /**\n     * Array of items that are atleast partially visible\n     *\n     * @return {Array}\n     */\n    getItemsInViewport: function() {\n      return this.getItemsWhere({\n        inViewport: true\n      });\n    },\n\n\n    /**\n     * Most recently active item.  \n     * \n     * @return {Object}\n     */\n    getPreviousItem: function() {\n      return this._previousItems[0];\n    },\n\n\n    /**\n     * Array of items that were previously\n     * active, with most recently active\n     * at the front of the array. \n     * \n     * @return {Array}\n     */\n    getPreviousItems: function() {\n      return this._previousItems;\n    },\n\n\n    /**\n     * Progress of the scroll needed to activate the \n     * last item on a 0.0 - 1.0 scale.\n     *\n     * 0 means the first item isn't yet active,\n     * and 1 means the last item is active, or \n     * has already been scrolled beyond active.\n     * \n     * @return {[type]} [description]\n     */\n    getPercentScrollToLastItem: function() {\n      return this._percentScrollToLastItem || 0;\n    },\n\n\n    /**\n     * Progress of the entire scroll distance, from the start \n     * of the first item a '0', until the very end of the last\n     * item, which is '1';\n     */\n    getScrollComplete: function() {\n      return this._totalScrollComplete || 0;\n    },\n\n    /**\n     * Return an array of all filtered items.\n     * @return {Array}\n     */\n    getFilteredItems: function() {\n      return this.getItemsWhere({\n        filtered: true\n      });\n    },\n\n\n    /**\n     * Return an array of all unfiltered items.\n     * @return {Array}\n     */\n    getUnFilteredItems: function() {\n      return this.getItemsWhere({\n        filtered: false\n      });\n    },\n\n\n    /**\n     * Return an array of all items belonging to a category.\n     * \n     * @param  {String} categorySlug\n     * @return {Array}\n     */\n    getItemsByCategory: function(categorySlug) {\n      return this.getItemsWhere({\n        category: categorySlug\n      });\n    },\n\n\n    /**\n     * Return an array of all category slugs\n     * \n     * @return {Array}\n     */\n    getCategorySlugs: function() {\n      return this._categories;\n    },\n\n\n    /**\n     * Change an item's status to filtered.\n     * \n     * @param  {Object} item\n     */\n    filter: function(item) {\n      if (!item.filtered) {\n        item.filtered = true;\n        this._trigger('itemfilter', null, item);\n      }\n    },\n\n\n    /**\n     * Change an item's status to unfiltered.\n     * \n     * @param  {Object} item\n     */\n    unfilter: function(item) {\n      if (item.filtered) {\n        item.filtered = false;\n        this._trigger('itemunfilter', null, item);\n      }\n    },\n\n    /**\n     * Change all items' status to filtered.\n     * \n     * @param  {Function} callback\n     */\n    filterAll: function(callback) {\n      callback = ($.isFunction(callback)) ? callback.bind(this) : $.noop;\n      var filterFnc = this.filter.bind(this);\n      this.getItems().forEach(filterFnc);\n    },\n\n    /**\n     * Change all items' status to unfiltered.\n     * \n     * @param  {Function} callback\n     */\n    unfilterAll: function(callback) {\n      callback = ($.isFunction(callback)) ? callback.bind(this) : $.noop;\n      var unfilterFnc = this.unfilter.bind(this);\n      this.getItems().forEach(unfilterFnc);\n    },\n\n\n    /**\n     * Filter items that pass an abritrary truth test. This is a light \n     * wrapper around `getItemsBy()` and `filter()`.\n     *\n     * Example: this.filterBy(function(item){return item.data.last_name === 'williams'})\n     *\n     * @param {Function} truthTest The function to check all items against\n     * @param  {Function} callback\n     */\n    filterBy: function(truthTest, callback) {\n      callback = ($.isFunction(callback)) ? callback.bind(this) : $.noop;\n      var filterFnc = this.filter.bind(this);\n      this.getItemsBy(truthTest).forEach(filterFnc);\n      callback();\n    },\n\n\n    /**\n     * Filter items where all the properties match an item's properties. This \n     * is a light wrapper around `getItemsWhere()` and `filter()`. See `getItemsWhere()`\n     * for more options and examples.\n     * \n     * Example: this.filterWhere({index:2})\n     *\n     * @param {Function} truthTest The function to check all items against\n     * @param  {Function} callback\n     */\n    filterWhere: function(properties, callback) {\n      callback = ($.isFunction(callback)) ? callback.bind(this) : $.noop;\n      var filterFnc = this.filter.bind(this);\n      this.getItemsWhere(properties).forEach(filterFnc);\n      callback();\n    },\n\n\n    /**\n     * Whether or not any of the item objects are active.\n     *\n     * @return {Boolean}\n     */\n    isContainerActive: function() {\n      return this._isActive;\n    },\n\n\n    /**\n     * Disable scroll updates. This is useful in the\n     * rare case when you want to manipulate the page\n     * but not have ScrollStory continue to check\n     * positions, fire events, etc. Usually a `disable`\n     * is temporary and followed by an `enable`.\n     */\n    disable: function() {\n      this.options.enabled = false;\n    },\n    \n    \n    /**\n     * Enable scroll updates\n     */\n    enable: function() {\n      this.options.enabled = true;\n    },\n\n\n    /**\n     * Update trigger offset. This is useful if a client\n     * app needs to, post-instantiation, change the trigger\n     * point, like after a window resize. \n     * \n     * @param  {Number} offset\n     */\n    updateTriggerOffset: function(offset) {\n      this.options.triggerOffset = offset;\n      this.updateOffsets();\n      this._trigger('triggeroffsetupdate', null, offsetToPx(offset));\n    },\n\n\n    /**\n     * Update scroll offset. This is useful if a client\n     * app needs to, post-instantiation, change the scroll\n     * offset, like after a window resize. \n     * @param  {Number} offset\n     */\n    updateScrollOffset: function(offset) {\n      this.options.scrollOffset = offset;\n      this.updateOffsets();\n      this._trigger('scrolloffsetupdate', null, offsetToPx(offset));\n    },\n\n\n    /**\n     * Determine which item should be active,\n     * and then make it so.\n     */\n    _setActiveItem: function() {\n\n      // top of the container is above the trigger point and the bottom is still below trigger point. \n      var containerInActiveArea = (this._distanceToFirstItemTopOffset <= 0 && (Math.abs(this._distanceToOffset) - this._height) < 0);\n\n      // only check items that aren't filtered\n      var items = this.getItemsWhere({\n        filtered: false\n      });\n\n      var activeItem;\n      items.forEach(function(item) {\n\n        // item has to have crossed the trigger offset\n        if (item.adjustedDistanceToOffset <= 0) {\n          if (!activeItem) {\n            activeItem = item;\n          } else {\n\n            // closer to trigger point than previously found item?\n            if (activeItem.adjustedDistanceToOffset < item.adjustedDistanceToOffset) {\n              activeItem = item;\n            }\n          }\n        }\n      });\n\n      // double check conditions around an active item\n      if (activeItem && !containerInActiveArea && this.options.disablePastLastItem) {\n        activeItem = false;\n\n        // not yet scrolled in, but auto-activate is set to true\n      } else if (!activeItem && this.options.autoActivateFirstItem && items.length > 0) {\n        activeItem = items[0];\n      }\n\n      if (activeItem) {\n        this._focusItem(activeItem);\n\n        // container\n        if (!this._isActive) {\n          this._isActive = true;\n          this._trigger('containeractive');\n        }\n\n      } else {\n        this._blurAllItems();\n\n        // container\n        if (this._isActive) {\n          this._isActive = false;\n          this._trigger('containerinactive');\n        }\n      }\n    },\n\n\n    /**\n     * Scroll to an item, making it active.\n     * \n     * @param  {Object}   item\n     * @param  {Object}   opts\n     * @param  {Function} callback  \n     */\n    _scrollToItem: function(item, opts, callback) {\n      callback = ($.isFunction(callback)) ? callback.bind(this) : $.noop;\n\n      /**\n       * Allows global scroll options to be overridden\n       * in one of two ways:\n       *\n       * 1. Higher priority: Passed in to scrollToItem directly via opts obj.\n       * 2. Lower priority: options set as an item.* property\n       */\n      opts = $.extend(true, {\n        // prefer item.scrollOffset over this.options.scrollOffset\n        scrollOffset: (item.scrollOffset !== false) ? offsetToPx(item.scrollOffset) : offsetToPx(this.options.scrollOffset),\n        speed: this.options.speed,\n        easing: this.options.easing\n      }, opts);\n\n\n      // because we animate to body and html for maximum compatiblity, \n      // we only want the callback to fire once. jQuery will call it \n      // once for each element otherwise\n      var debouncedCallback = debounce(callback, 100);\n\n      // position to travel to\n      var scrolllTop = item.el.offset().top - offsetToPx(opts.scrollOffset);\n      $('html, body').stop(true).animate({\n          scrollTop: scrolllTop\n      }, opts.speed, opts.easing, debouncedCallback);\n    },\n\n\n    /**\n     * Excecute a callback function that expects an\n     * item as its paramamter for each items.\n     *\n     * Optionally, a item or array of items of exceptions\n     * can be passed in. They'll not call the callback.\n     *\n     * @param  {Function} callback         Method to call, and pass in exepctions\n     * @param  {Object/Array}   exceptions\n     */\n    applyToAllItems: function(callback, exceptions) {\n      exceptions = ($.isArray(exceptions)) ? exceptions : [exceptions];\n      callback = ($.isFunction(callback)) ? callback.bind(this) : $.noop;\n\n      var items = this.getItems();\n      var i = 0;\n      var length = items.length;\n      var item;\n\n      for (i = 0; i < length; i++) {\n        item = items[i];\n        if (exceptions.indexOf(item) === -1) {\n          callback(item, i);\n        }\n      }\n    },\n\n\n    /**\n     * Unfocus all items.\n     *\n     * @param  {Object/Array} exceptions item or array of items to not blur\n     */\n    _blurAllItems: function(exceptions) {\n      this.applyToAllItems(this._blurItem.bind(this), exceptions);\n\n      if (!exceptions) {\n        this._activeItem = undefined;\n      }\n    },\n\n    /**\n     * Unfocus an item\n     * @param  {Object}\n     */\n    _blurItem: function(item) {\n      if (item.active) {\n        item.active = false;\n        this._trigger('itemblur', null, item);\n      }\n    },\n\n\n    /**\n     * Given an item, give it focus. Focus is exclusive\n     * so we unfocus any other item.\n     *\n     * @param  {Object} item object\n     */\n    _focusItem: function(item) {\n      if (!item.active && !item.filtered) {\n        this._blurAllItems(item);\n\n        // make active\n        this._activeItem = item;\n        item.active = true;\n\n        // notify clients of changes\n        this._trigger('itemfocus', null, item);\n      }\n    },\n\n\n    /**\n     * Iterate through items and update their top offset.\n     * Useful if items have been added, removed,\n     * repositioned externally, and after window resize\n     *\n     * Based on:\n     * http://javascript.info/tutorial/coordinates\n     * http://stackoverflow.com/questions/123999/how-to-tell-if-a-dom-element-is-visible-in-the-current-viewport/7557433#7557433\n     */\n    updateOffsets: function() {\n      var bodyElem = document.body;\n      var docElem = document.documentElement;\n\n      var scrollTop = window.pageYOffset || docElem.scrollTop || bodyElem.scrollTop;\n      var clientTop = docElem.clientTop || bodyElem.clientTop || 0;\n      var items = this.getItems();\n      var i = 0;\n      var length = items.length;\n      var item;\n      var box;\n\n      // individual items\n      for (i = 0; i < length; i++) {\n        item = items[i];\n        box = item.el[0].getBoundingClientRect();\n\n        // add or update item properties\n        item.width = box.width;\n        item.height = box.height;\n        item.topOffset = box.top + scrollTop - clientTop;\n      }\n\n      // container\n      box = this.el.getBoundingClientRect();\n      this._height = box.height;\n      this._width = box.width;\n      this._topOffset = box.top + scrollTop - clientTop;\n\n      this._trigger('updateoffsets');\n    },\n\n    _updateScrollPositions: function() {\n      var bodyElem = document.body;\n      var docElem = document.documentElement;\n      var scrollTop = window.pageYOffset || docElem.scrollTop || bodyElem.scrollTop;\n      var wHeight = window.innerHeight || docElem.clientHeight;\n      var wWidth = window.innerWidth || docElem.clientWidth;\n      var triggerOffset = offsetToPx(this.options.triggerOffset);\n\n\n      // update item scroll positions\n      var items = this.getItems();\n      var length = items.length;\n      var lastItem = items[length -1];\n      var i = 0;\n      var item;\n      var rect;\n      var previouslyInViewport;\n\n      // track total scroll across all items\n      var totalScrollComplete = 0;\n\n      for (i = 0; i < length; i++) {\n        item = items[i];\n        rect = item.el[0].getBoundingClientRect();\n        item.distanceToOffset = Math.floor(item.topOffset - scrollTop - triggerOffset); // floor to prevent some off-by-fractional px in determining active item\n        item.adjustedDistanceToOffset = (item.triggerOffset === false) ? item.distanceToOffset : item.topOffset - scrollTop - item.triggerOffset;\n\n        // percent through this item's active scroll. expressed 0 - 1;\n        if (item.distanceToOffset >= 0) {\n          item.percentScrollComplete = 0;\n        } else if (Math.abs(item.distanceToOffset) >= rect.height){\n          item.percentScrollComplete = 1;\n        } else {\n          item.percentScrollComplete = Math.abs(item.distanceToOffset) / rect.height;\n        }\n\n        // track percent scroll \n        totalScrollComplete = totalScrollComplete + item.percentScrollComplete;\n\n        // track viewport status\n        previouslyInViewport = item.inViewport;\n        item.inViewport = rect.bottom > 0 && rect.right > 0 && rect.left < wWidth && rect.top < wHeight;\n        item.fullyInViewport = rect.top >= 0 && rect.left >= 0 && rect.bottom <= wHeight && rect.right <= wWidth;\n\n        if (item.inViewport && !previouslyInViewport) {\n          this._trigger('itementerviewport', null, item);\n        } else if (!item.inViewport && previouslyInViewport) {\n          this._trigger('itemexitviewport', null, item);\n        }\n      }\n\n      // update container scroll position\n      this._distanceToFirstItemTopOffset = items[0].adjustedDistanceToOffset;\n\n      // takes into account other elements that might make the top of the \n      // container different than the topoffset of the first item.\n      this._distanceToOffset = this._topOffset - scrollTop - triggerOffset;\n\n\n      // percent of the total scroll needed to activate the last item\n      var percentScrollToLastItem = 0;\n      if (this._distanceToOffset < 0) {\n        percentScrollToLastItem = 1 - (lastItem.distanceToOffset / (this._height - lastItem.height));\n        percentScrollToLastItem = (percentScrollToLastItem < 1) ? percentScrollToLastItem : 1; // restrict range\n      }\n\n      this._percentScrollToLastItem = percentScrollToLastItem;\n\n      this._totalScrollComplete = totalScrollComplete / length;\n    },\n\n\n    /**\n     * Add items to the running list given any of the\n     * following inputs:\n     *\n     * 1. jQuery selection. Items will be generated\n     * from the selection, and any data-* attributes\n     * will be added to the item's data object.\n     *\n     * 2. A string selector to search for elements\n     * within our container. Items will be generated\n     * from that selection, and any data-* attributes\n     * will be added to the item's data object.\n     *\n     * 3. Array of objects. All needed markup will\n     * be generated, and the data in each object will\n     * be added to the item's data object.\n     *\n     * 4. If no 'items' param, we search for items\n     * using the options.contentSelector string.\n     *\n     *\n     * TODO: ensure existing items aren't re-added.\n     * This is expecially important for the empty items\n     * option, and will give us the ability to do\n     * infinite scrolls, etc.\n     *\n     * @param {jQuery Object/String/Array} items\n     */\n    addItems: function(items, opts) {\n\n      opts = $.extend(true, {\n        handleRepaint: true\n      }, opts);\n\n      // use an existing jQuery selection\n      if (items instanceof $) {\n        this._prepItemsFromSelection(items);\n\n        // a custom selector to use within our container\n      } else if (typeof items === 'string') {\n        this._prepItemsFromSelection(this.$el.find(items));\n\n        // array objects, which will be used to create markup\n      } else if ($.isArray(items)) {\n        this._prepItemsFromData(items);\n\n        // search for elements with the default selector\n      } else {\n        this._prepItemsFromSelection(this.$el.find(this.options.contentSelector));\n      }\n\n      // after instantiation and any addItems, we must have \n      // atleast one valid item. If not, plugin is misconfigured.\n      if (this.getItems().length < 1) {\n        throw new Error('addItems found no valid items.');\n      }\n\n      if (opts.handleRepaint) {\n        this._handleRepaint();\n      }\n    },\n\n    /**\n     * Remove any classes added during\n     * use and unbind all events.\n     */\n    destroy: function(removeMarkup) {\n      removeMarkup = removeMarkup || false;\n\n      if(removeMarkup){\n        this.each(function(item){\n          item.el.remove();\n        });\n      }\n\n      // cleanup dom / events and \n      // run any user code\n      this._trigger('destroy');\n\n      // plugin wrapper disallows multiple scrollstory\n      // instances on the same element. after a destory,\n      // allow plugin to reattach to this element.\n       var containerData = this.$el.data();\n       containerData['plugin_' + pluginName] = null;\n\n      // TODO: destroy the *instance*?\n    },\n\n\n    /**\n     * Update items' scroll positions and \n     * determine which one is active based \n     * on those positions. Useful during\n     * scrolls, resizes and other events\n     * that repaint the page. \n     *\n     * updateOffsets should be used \n     * with caution, as it's CPU intensive,\n     * and only useful it item sizes or\n     * scrollOffsets have changed.\n     * \n     * @param  {Boolean} updateOffsets \n     * @return {[type]} [description]\n     */\n    _handleRepaint: function(updateOffsets) {\n      updateOffsets = (updateOffsets === false) ? false : true;\n      \n      if (updateOffsets) {\n        this.updateOffsets(); // must be called first\n      }\n\n      this._updateScrollPositions(); // must be called second\n      this._setActiveItem(); // must be called third\n    },\n\n\n    /**\n     * Keep state correct while scrolling\n     */\n    _handleScroll: function() {\n      if (this.options.enabled) {\n        this._handleRepaint(false);\n        this._trigger('containerscroll');\n      }\n    },\n\n    /**\n     * Keep state correct while resizing\n     */\n    _handleResize: function() {\n      winHeight = $window.height();\n      \n      if (this.options.enabled && this.options.autoUpdateOffsets) {\n\n        if (offsetIsAPercentage(this.options.triggerOffset)) {\n          this.updateTriggerOffset(this.options.triggerOffset);\n        }\n\n        if (offsetIsAPercentage(this.options.scrollOffset)) {\n          this.updateScrollOffset(this.options.scrollOffset);\n        }\n\n        this._debouncedHandleRepaint();\n        this._trigger('containerresize');\n      }\n    },\n\n    // Handlers for public events that maintain state\n    // of the ScrollStory instance.\n\n    _onSetup: function() {\n      this.$el.addClass(pluginName);\n    },\n\n    _onDestroy: function() {\n\n      // remove events\n      this.$el.off(eventNameSpace);\n      $window.off(eventNameSpace);\n\n      // item classes\n      var itemClassesToRemove = ['scrollStoryItem', 'inviewport', 'active', 'filtered'].join(' ');\n      this.each(function(item){\n        item.el.removeClass(itemClassesToRemove);\n      });\n\n      // container classes\n      this.$el.removeClass(function(i, classNames){\n        var classNamesToRemove = [];\n        classNames.split(' ').forEach(function(c){\n          if (c.lastIndexOf(pluginName) === 0 ){\n            classNamesToRemove.push(c);\n          }\n        });\n        return classNamesToRemove.join(' ');\n      });\n\n      this.$trigger.remove();\n    },\n\n    _onContainerActive: function() {\n      this.$el.addClass(pluginName + 'Active');\n    },\n\n    _onContainerInactive: function() {\n      this.$el.removeClass(pluginName + 'Active');\n    },\n\n    _onItemFocus: function(ev, item) {\n      item.el.addClass('active');\n      this._manageContainerClasses('scrollStoryActiveItem-',item.id);\n\n      // trigger catgory change if not previously active or\n      // this item's category is different from the last\n      if (item.category) {\n        if ( (this.getPreviousItem() && this.getPreviousItem().category !== item.category) || !this.isContainerActive()) {\n          this._trigger('categoryfocus', null, item.category);\n\n          if (this.getPreviousItem()) {\n            this._trigger('categoryblur', null, this.getPreviousItem().category);\n          }\n        }\n      }\n    },\n\n    _onItemBlur: function(ev, item) {\n      this._previousItems.unshift(item);\n      item.el.removeClass('active');\n    },\n\n    _onItemEnterViewport: function(ev, item) {\n      item.el.addClass('inviewport');\n    },\n\n    _onItemExitViewport: function(ev, item) {\n      item.el.removeClass('inviewport');\n    },\n\n    _onItemFilter: function(ev, item) {\n      item.el.addClass('filtered');\n      if (this.options.autoUpdateOffsets) {\n        this._debouncedHandleRepaint();\n      }\n    },\n\n    _onItemUnfilter: function(ev, item) {\n      item.el.removeClass('filtered');\n      if (this.options.autoUpdateOffsets) {\n        this._debouncedHandleRepaint();\n      }\n    },\n\n    _onCategoryFocus: function(ev, category) {\n      this._manageContainerClasses('scrollStoryActiveCategory-',category);\n    },\n\n    _onTriggerOffsetUpdate: function(ev, offset) {\n      this.$trigger.css({\n        top: offset + 'px'\n      });\n    },\n\n\n\n    /**\n     * Given a prefix string like 'scrollStoryActiveCategory-',\n     * and a value like 'fruit', add 'scrollStoryActiveCategory-fruit'\n     * class to the containing element after removing any other \n     * 'scrollStoryActiveCategory-*' classes\n     * @param  {[type]} prefix [description]\n     * @param  {[type]} value  [description]\n     * @return {[type]}        [description]\n     */\n    _manageContainerClasses: function(prefix, value) {\n      this.$el.removeClass(function(index, classes){\n        return classes.split(' ').filter(function(c) {\n            return c.lastIndexOf(prefix, 0) === 0;\n        }).join(' ');\n      });\n      this.$el.addClass(prefix+value);\n    },\n\n\n    /**\n     * Given a jQuery selection, add those elements\n     * to the internal items array.\n     *\n     * @param  {Object} $jQuerySelection\n     */\n    _prepItemsFromSelection: function($selection) {\n      var that = this;\n      $selection.each(function() {\n        that._addItem({}, $(this));\n      });\n    },\n\n\n    /**\n     * Given array of data, append markup and add\n     * data to internal items array.\n     * @param  {Array} items\n     */\n    _prepItemsFromData: function(items) {\n      var that = this;\n\n      // drop period from the default selector, so we can \n      // add it to the class attr in markup\n      var selector = this.options.contentSelector.replace(/\\./g, '');\n\n      var frag = document.createDocumentFragment();\n      items.forEach(function(data) {\n        var $item = $('<div class=\"' + selector + '\"></div>');\n        that._addItem(data, $item);\n        frag.appendChild($item.get(0));\n      });\n\n      this.$el.append(frag);\n    },\n\n\n    /**\n     * Given item user data, and an aleady appended\n     * jQuery object, create an item for internal items array.\n     *\n     * @param {Object} data\n     * @param {jQuery Object} $el\n     */\n    _addItem: function(data, $el) {\n      var domData = $el.data();\n\n      var item = {\n        index: this._items.length,\n        el: $el,\n        // id is from markup id attribute, data or dynamically generated\n        id: $el.attr('id') ? $el.attr('id') : (data.id) ? data.id : 'story' + instanceCounter + '-' + this._items.length,\n\n        // item's data is from client data or data-* attrs. prefer data-* attrs over client data.\n        data: $.extend({}, data, domData),\n\n        category: domData.category || data.category, // string. optional category slug this item belongs to. prefer data-category attribute\n        tags: data.tags || [], // optional tag or tags for this item. Can take an array of string, or a cvs string that'll be converted into array of strings.\n        scrollStory: this, // reference to this instance of scrollstory\n\n        // in-focus item\n        active: false,\n\n        // has item been filtered\n        filtered: false,\n\n        // on occassion, the scrollToItem() offset may need to be adjusted for a\n        // particular item. this overrides this.options.scrollOffset set on instantiation\n        scrollOffset: false,\n\n        // on occassion we want to trigger an item at a non-standard offset.\n        triggerOffset: false,\n\n        // if any part is viewable in the viewport.\n        inViewport: false\n\n      };\n\n      // ensure id exist in dom\n      if (!$el.attr('id')) {\n        $el.attr('id', item.id);\n      }\n\n      $el.addClass('scrollStoryItem');\n\n      // global record\n      this._items.push(item);\n\n      // quick lookup\n      this._itemsById[item.id] = item;\n\n      this._trigger('itembuild', null, item);\n\n      // An item's category is saved after the the itembuild event\n      // to allow for user code to specify a category client-side in \n      // that event callback or handler.\n      if (item.category && this._categories.indexOf(item.category) === -1) {\n        this._categories.push(item.category);\n      }\n\n      // this._tags.push(item.tags);\n    },\n\n\n    /**\n     * Manage callbacks and event dispatching.\n     *\n     * Based very heavily on jQuery UI's implementaiton\n     * https://github.com/jquery/jquery-ui/blob/9d0f44fd7b16a66de1d9b0d8c5e4ab954d83790f/ui/widget.js#L492\n     *\n     * @param  {String} eventType\n     * @param  {Object} event\n     * @param  {Object} data\n     */\n    _trigger: function(eventType, event, data) {\n      var callback = this.options[eventType];\n      var prop, orig;\n\n      if ($.isFunction(callback)) {\n        data = data || {};\n\n        event = $.Event(event);\n        event.target = this.el;\n        event.type = eventType;\n\n        // copy original event properties over to the new event\n        orig = event.originalEvent;\n        if (orig) {\n          for (prop in orig) {\n            if (!(prop in event)) {\n              event[prop] = orig[prop];\n            }\n          }\n        }\n\n        // fire event\n        this.$el.trigger(event, data);\n\n        // call the callback\n        var boundCb = this.options[eventType].bind(this);\n        boundCb(event, data);\n      }\n    }\n  }; // end plugin.prototype\n\n\n  /**\n   * Debounced version of prototype methods\n   */\n  ScrollStory.prototype.debouncedUpdateOffsets = debounce(ScrollStory.prototype.updateOffsets, 100);\n  ScrollStory.prototype._debouncedHandleRepaint = debounce(ScrollStory.prototype._handleRepaint, 100);\n\n\n\n  // A really lightweight plugin wrapper around the constructor,\n  // preventing multiple instantiations\n  $.fn[pluginName] = function(options) {\n    return this.each(function() {\n      if (!$.data(this, 'plugin_' + pluginName)) {\n        $.data(this, 'plugin_' + pluginName, new ScrollStory(this, options));\n      }\n    });\n  };\n}));","/* eslint-env browser */\n/* globals $ */\nimport 'scrollstory/jquery.scrollstory';\nimport blueimp from 'blueimp-gallery/js/blueimp-gallery';\n\nfunction loadItem(item) {\n  const slides = item.el.find('.slide-container a').get();\n\n  blueimp(slides, {\n    container: item.el.find('.blueimp-gallery')[0],\n    carousel: true,\n    titleElement: '.slide-caption',\n    srcsetProperty: 'urlset',\n    startSlideshow: false,\n    onslide(index, slide) {\n      const text = this.list[index].getAttribute('data-credits');\n      const node = this.container.find('.credits');\n      node.empty();\n      if (text) {\n        node[0].appendChild(document.createTextNode(text));\n      }\n    },\n  });\n}\n\n$(document).ready(function() {\n  const $story = $('#scrollytelling');\n\n  const scrollStory = $story\n    .scrollStory({\n      contentSelector: '.part',\n      triggerOffset: 0,\n    })\n    .data('plugin_scrollStory');\n\n  const storyItems = scrollStory.getItems();\n  loadItem(storyItems[0]);\n});\n","module.exports = jQuery;"],"sourceRoot":""}