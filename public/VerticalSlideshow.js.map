{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./node_modules/stickybits/src/jquery.stickybits.js","webpack:///./node_modules/stickybits/src/stickybits.js","webpack:///./src/editor/items/VerticalSlideshow.js"],"names":[],"mappings":";QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;;AClFA;AAAA;AAAqC;;AAErC;AACA;AACA;AACA;AACA,aAAa,2DAAU;AACvB;AACA;AACA;;;;;;;;;;;;;ACTA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,+EAA+E,sBAAsB;AACrG;;AAEA;;AAEA;;AAEA,mBAAmB,qBAAqB;AACxC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,qBAAqB;AACrB,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,qBAAqB,mBAAmB;AACxC,2BAA2B,UAAU;AACrC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,wBAAwB;AAC7C,WAAW;AACX,oBAAoB,iBAAiB;AACrC,SAAS;AACT;AACA;AACA;AACA,WAAW;AACX,qBAAqB;AACrB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,KAAK;AAClB,WAAW;AACX,oBAAoB,gBAAgB;AACpC,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,yCAAyC;AAC1D,kBAAkB,0CAA0C;AAC5D,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,2BAA2B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACe;AACf;AACA;;;;;;;;;;;;;ACtfA;AAAA;AAAA;AACA;;AAE0C;;AAE1C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA","file":"VerticalSlideshow.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","import stickybits from './stickybits'\n\nif (typeof window !== 'undefined') {\n  const plugin = window.$ || window.jQuery || window.Zepto\n  if (plugin) {\n    plugin.fn.stickybits = function stickybitsPlugin (opts) {\n      return stickybits(this, opts)\n    }\n  }\n}\n","/*\n  STICKYBITS 💉\n  --------\n  > a lightweight alternative to `position: sticky` polyfills 🍬\n  --------\n  - each method is documented above it our view the readme\n  - Stickybits does not manage polymorphic functionality (position like properties)\n  * polymorphic functionality: (in the context of describing Stickybits)\n    means making things like `position: sticky` be loosely supported with position fixed.\n    It also means that features like `useStickyClasses` takes on styles like `position: fixed`.\n  --------\n  defaults 🔌\n  --------\n  - version = `package.json` version\n  - userAgent = viewer browser agent\n  - target = DOM element selector\n  - noStyles = boolean\n  - offset = number\n  - parentClass = 'string'\n  - scrollEl = window || DOM element selector || DOM element\n  - stickyClass = 'string'\n  - stuckClass = 'string'\n  - useStickyClasses = boolean\n  - useFixed = boolean\n  - useGetBoundingClientRect = boolean\n  - verticalPosition = 'string'\n  - applyStyle = function\n  --------\n  props🔌\n  --------\n  - p = props {object}\n  --------\n  instance note\n  --------\n  - stickybits parent methods return this\n  - stickybits instance methods return an instance item\n  --------\n  nomenclature\n  --------\n  - target => el => e\n  - props => o || p\n  - instance => item => it\n  --------\n  methods\n  --------\n  - .definePosition = defines sticky or fixed\n  - .addInstance = an array of objects for each Stickybits Target\n  - .getClosestParent = gets the parent for non-window scroll\n  - .getTopPosition = gets the element top pixel position from the viewport\n  - .computeScrollOffsets = computes scroll position\n  - .toggleClasses = older browser toggler\n  - .manageState = manages sticky state\n  - .removeInstance = removes an instance\n  - .cleanup = removes all Stickybits instances and cleans up dom from stickybits\n*/\nclass Stickybits {\n  constructor (target, obj) {\n    const o = typeof obj !== 'undefined' ? obj : {}\n    this.version = 'VERSION'\n    this.userAgent = window.navigator.userAgent || 'no `userAgent` provided by the browser'\n    this.props = {\n      customStickyChangeNumber: o.customStickyChangeNumber || null,\n      noStyles: o.noStyles || false,\n      stickyBitStickyOffset: o.stickyBitStickyOffset || 0,\n      parentClass: o.parentClass || 'js-stickybit-parent',\n      scrollEl: typeof o.scrollEl === 'string' ? document.querySelector(o.scrollEl) : o.scrollEl || window,\n      stickyClass: o.stickyClass || 'js-is-sticky',\n      stuckClass: o.stuckClass || 'js-is-stuck',\n      stickyChangeClass: o.stickyChangeClass || 'js-is-sticky--change',\n      useStickyClasses: o.useStickyClasses || false,\n      useFixed: o.useFixed || false,\n      useGetBoundingClientRect: o.useGetBoundingClientRect || false,\n      verticalPosition: o.verticalPosition || 'top',\n      applyStyle: o.applyStyle || ((item, style) => this.applyStyle(item, style)),\n    }\n    /*\n      define positionVal after the setting of props, because definePosition looks at the props.useFixed\n      ----\n      -  uses a computed (`.definePosition()`)\n      -  defined the position\n    */\n    this.props.positionVal = this.definePosition() || 'fixed'\n\n    this.instances = []\n\n    const {\n      positionVal,\n      verticalPosition,\n      noStyles,\n      stickyBitStickyOffset,\n    } = this.props\n    const verticalPositionStyle = verticalPosition === 'top' && !noStyles ? `${stickyBitStickyOffset}px` : ''\n    const positionStyle = positionVal !== 'fixed' ? positionVal : ''\n\n    this.els = typeof target === 'string' ? document.querySelectorAll(target) : target\n\n    if (!('length' in this.els)) this.els = [this.els]\n\n    for (let i = 0; i < this.els.length; i++) {\n      const el = this.els[i]\n\n      var instance = this.addInstance(el, this.props)\n      // set vertical position\n      this.props.applyStyle(\n        {\n          styles: {\n            [verticalPosition]: verticalPositionStyle,\n            position: positionStyle,\n          },\n          classes: {},\n        },\n        instance,\n      )\n      this.manageState(instance)\n\n      // instances are an array of objects\n      this.instances.push(instance)\n    }\n  }\n\n  /*\n    setStickyPosition ✔️\n    --------\n    —  most basic thing stickybits does\n    => checks to see if position sticky is supported\n    => defined the position to be used\n    => stickybits works accordingly\n  */\n  definePosition () {\n    let stickyProp\n    if (this.props.useFixed) {\n      stickyProp = 'fixed'\n    } else {\n      const prefix = ['', '-o-', '-webkit-', '-moz-', '-ms-']\n      const test = document.head.style\n      for (let i = 0; i < prefix.length; i += 1) {\n        test.position = `${prefix[i]}sticky`\n      }\n      stickyProp = test.position ? test.position : 'fixed'\n      test.position = ''\n    }\n    return stickyProp\n  }\n\n  /*\n    addInstance ✔️\n    --------\n    — manages instances of items\n    - takes in an el and props\n    - returns an item object\n    ---\n    - target = el\n    - o = {object} = props\n      - scrollEl = 'string' | object\n      - verticalPosition = number\n      - off = boolean\n      - parentClass = 'string'\n      - stickyClass = 'string'\n      - stuckClass = 'string'\n    ---\n    - defined later\n      - parent = dom element\n      - state = 'string'\n      - offset = number\n      - stickyStart = number\n      - stickyStop = number\n    - returns an instance object\n  */\n  addInstance (el, props) {\n    const item = {\n      el,\n      parent: el.parentNode,\n      props,\n    }\n    if (props.positionVal === 'fixed' || props.useStickyClasses) {\n      this.isWin = this.props.scrollEl === window\n      const se = this.isWin ? window : this.getClosestParent(item.el, item.props.scrollEl)\n      this.computeScrollOffsets(item)\n      this.toggleClasses(item.parent, '', props.parentClass)\n      item.state = 'default'\n      item.stateChange = 'default'\n      item.stateContainer = () => this.manageState(item)\n      se.addEventListener('scroll', item.stateContainer)\n    }\n    return item\n  }\n\n  /*\n    --------\n    getParent 👨‍\n    --------\n    - a helper function that gets the target element's parent selected el\n    - only used for non `window` scroll elements\n    - supports older browsers\n  */\n  getClosestParent (el, match) {\n    // p = parent element\n    const p = match\n    let e = el\n    if (e.parentElement === p) return p\n    // traverse up the dom tree until we get to the parent\n    while (e.parentElement !== p) e = e.parentElement\n    // return parent element\n    return p\n  }\n\n  /*\n    --------\n    getTopPosition\n    --------\n    - a helper function that gets the topPosition of a Stickybit element\n    - from the top level of the DOM\n  */\n  getTopPosition (el) {\n    if (this.props.useGetBoundingClientRect) {\n      return el.getBoundingClientRect().top + (this.props.scrollEl.pageYOffset || document.documentElement.scrollTop)\n    }\n    let topPosition = 0\n    do {\n      topPosition = el.offsetTop + topPosition\n    } while ((el = el.offsetParent))\n    return topPosition\n  }\n\n  /*\n    computeScrollOffsets 📊\n    ---\n    computeScrollOffsets for Stickybits\n    - defines\n      - offset\n      - start\n      - stop\n  */\n  computeScrollOffsets (item) {\n    const it = item\n    const p = it.props\n    const el = it.el\n    const parent = it.parent\n    const isCustom = !this.isWin && p.positionVal === 'fixed'\n    const isTop = p.verticalPosition !== 'bottom'\n    const scrollElOffset = isCustom ? this.getTopPosition(p.scrollEl) : 0\n    const stickyStart = isCustom\n      ? this.getTopPosition(parent) - scrollElOffset\n      : this.getTopPosition(parent)\n    const stickyChangeOffset = p.customStickyChangeNumber !== null\n      ? p.customStickyChangeNumber\n      : el.offsetHeight\n    const parentBottom = stickyStart + parent.offsetHeight\n    it.offset = !isCustom ? scrollElOffset + p.stickyBitStickyOffset : 0\n    it.stickyStart = isTop ? stickyStart - it.offset : 0\n    it.stickyChange = it.stickyStart + stickyChangeOffset\n    it.stickyStop = isTop\n      ? parentBottom - (el.offsetHeight + it.offset)\n      : parentBottom - window.innerHeight\n  }\n\n  /*\n    toggleClasses ⚖️\n    ---\n    toggles classes (for older browser support)\n    r = removed class\n    a = added class\n  */\n  toggleClasses (el, r, a) {\n    const e = el\n    const cArray = e.className.split(' ')\n    if (a && cArray.indexOf(a) === -1) cArray.push(a)\n    const rItem = cArray.indexOf(r)\n    if (rItem !== -1) cArray.splice(rItem, 1)\n    e.className = cArray.join(' ')\n  }\n\n  /*\n    manageState 📝\n    ---\n    - defines the state\n      - normal\n      - sticky\n      - stuck\n  */\n  manageState (item) {\n    // cache object\n    const it = item\n    const p = it.props\n    const state = it.state\n    const stateChange = it.stateChange\n    const start = it.stickyStart\n    const change = it.stickyChange\n    const stop = it.stickyStop\n    // cache props\n    const pv = p.positionVal\n    const se = p.scrollEl\n    const sticky = p.stickyClass\n    const stickyChange = p.stickyChangeClass\n    const stuck = p.stuckClass\n    const vp = p.verticalPosition\n    const isTop = vp !== 'bottom'\n    const aS = p.applyStyle\n    const ns = p.noStyles\n    /*\n      requestAnimationFrame\n      ---\n      - use rAF\n      - or stub rAF\n    */\n    const rAFStub = function rAFDummy (f) { f() }\n    const rAF = !this.isWin\n      ? rAFStub\n      : window.requestAnimationFrame ||\n      window.mozRequestAnimationFrame ||\n      window.webkitRequestAnimationFrame ||\n      window.msRequestAnimationFrame ||\n      rAFStub\n\n    /*\n      define scroll vars\n      ---\n      - scroll\n      - notSticky\n      - isSticky\n      - isStuck\n    */\n    const scroll = this.isWin ? (window.scrollY || window.pageYOffset) : se.scrollTop\n    const notSticky = scroll > start && scroll < stop && (state === 'default' || state === 'stuck')\n    const isSticky = isTop && scroll <= start && (state === 'sticky' || state === 'stuck')\n    const isStuck = scroll >= stop && state === 'sticky'\n    /*\n      Unnamed arrow functions within this block\n      ---\n      - help wanted or discussion\n      - view test.stickybits.js\n        - `stickybits .manageState  `position: fixed` interface` for more awareness 👀\n    */\n    if (notSticky) {\n      it.state = 'sticky'\n    } else if (isSticky) {\n      it.state = 'default'\n    } else if (isStuck) {\n      it.state = 'stuck'\n    }\n\n    const isStickyChange = scroll >= change && scroll <= stop\n    const isNotStickyChange = scroll < change / 2 || scroll > stop\n    if (isNotStickyChange) {\n      it.stateChange = 'default'\n    } else if (isStickyChange) {\n      it.stateChange = 'sticky'\n    }\n\n    // Only apply new styles if the state has changed\n    if (state === it.state && stateChange === it.stateChange) return\n    rAF(() => {\n      const stateStyles = {\n        sticky: {\n          styles: {\n            position: pv,\n            top: '',\n            bottom: '',\n            [vp]: `${p.stickyBitStickyOffset}px`,\n          },\n          classes: { [sticky]: true },\n        },\n        default: {\n          styles: {\n            [vp]: '',\n          },\n          classes: {},\n        },\n        stuck: {\n          styles: {\n            [vp]: '',\n            /**\n             * leave !this.isWin\n             * @example https://codepen.io/yowainwright/pen/EXzJeb\n             */\n            ...((pv === 'fixed' && !ns) || !this.isWin ? {\n              position: 'absolute',\n              top: '',\n              bottom: '0',\n            } : {}),\n          },\n          classes: { [stuck]: true },\n        },\n      }\n\n      if (pv === 'fixed') {\n        stateStyles.default.styles.position = ''\n      }\n\n      const style = stateStyles[it.state]\n      style.classes = {\n        [stuck]: !!style.classes[stuck],\n        [sticky]: !!style.classes[sticky],\n        [stickyChange]: isStickyChange,\n      }\n\n      aS(style, item)\n    })\n  }\n\n  /*\n    applyStyle\n    ---\n    - apply the given styles and classes to the element\n  */\n  applyStyle ({ styles, classes }, item) {\n    // cache object\n    const it = item\n    const e = it.el\n    const p = it.props\n    const stl = e.style\n    // cache props\n    const ns = p.noStyles\n\n    const cArray = e.className.split(' ')\n    // Disable due to bug with old versions of eslint-scope and for ... in\n    // https://github.com/eslint/eslint/issues/12117\n    // eslint-disable-next-line no-unused-vars\n    for (const cls in classes) {\n      const addClass = classes[cls]\n      if (addClass) {\n        if (cArray.indexOf(cls) === -1) cArray.push(cls)\n      } else {\n        const idx = cArray.indexOf(cls)\n        if (idx !== -1) cArray.splice(idx, 1)\n      }\n    }\n\n    e.className = cArray.join(' ')\n\n    if (styles['position']) {\n      stl['position'] = styles['position']\n    }\n\n    if (ns) return\n\n    // eslint-disable-next-line no-unused-vars\n    for (const key in styles) {\n      stl[key] = styles[key]\n    }\n  }\n\n  update (updatedProps = null) {\n    this.instances.forEach((instance) => {\n      this.computeScrollOffsets(instance)\n      if (updatedProps) {\n        // eslint-disable-next-line no-unused-vars\n        for (const updatedProp in updatedProps) {\n          instance.props[updatedProp] = updatedProps[updatedProp]\n        }\n      }\n    })\n\n    return this\n  }\n\n  /*\n    removes an instance 👋\n    --------\n    - cleanup instance\n  */\n  removeInstance (instance) {\n    const e = instance.el\n    const p = instance.props\n\n    this.applyStyle(\n      {\n        styles: { position: '', [p.verticalPosition]: '' },\n        classes: { [p.stickyClass]: '', [p.stuckClass]: '' },\n      },\n      instance,\n    )\n\n    this.toggleClasses(e.parentNode, p.parentClass)\n  }\n\n  /*\n    cleanup 🛁\n    --------\n    - cleans up each instance\n    - clears instance\n  */\n  cleanup () {\n    for (let i = 0; i < this.instances.length; i += 1) {\n      const instance = this.instances[i]\n      if (instance.stateContainer) {\n        instance.props.scrollEl.removeEventListener('scroll', instance.stateContainer)\n      }\n      this.removeInstance(instance)\n    }\n    this.manageState = false\n    this.instances = []\n  }\n}\n\n/*\n  export\n  --------\n  exports StickBits to be used 🏁\n*/\nexport default function stickybits (target, o) {\n  return new Stickybits(target, o)\n}\n","/* eslint-env browser */\n/* globals $ */\n\nimport 'stickybits/src/jquery.stickybits';\n\nlet $story;\nlet stickybitsInstance;\n\nfunction loadItem(item) {\n  stickybitsInstance = item.el.find('.bg-image').stickybits();\n}\n\n// code needed to bootstrap editor preview\n$(document).ready(function() {\n  $story = $('#scrollytelling');\n\n  $story\n    .scrollStory({\n      contentSelector: '.part',\n      triggerOffset: 0,\n      autoActivateFirstItem: true,\n      containeractive: function() {\n        const item = this.getActiveItem();\n        loadItem(item);\n      },\n    })\n    .data('plugin_scrollStory');\n});\n\n// code needed to refresh editor preview\nwindow.refresh = function() {\n  stickybitsInstance.cleanup();\n  const item = $story.data('plugin_scrollStory').getActiveItem();\n  loadItem(item);\n};\n"],"sourceRoot":""}